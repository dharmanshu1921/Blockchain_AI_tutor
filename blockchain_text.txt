A blockchain is a growing list of records, called blocks, which are linked using cryptography. Each block contains a cryptographic hash of the previous block, a timestamp, and transaction data. Blockchain has been in a lot of buzz these days. And that is mainly because it is backbone of the very famous cryptocurrency in the world - the Bitcoin. Many Governments and leading Banks have decided to bring many of their conventional transactions based on Blockchain concept. The applications and potential of this framework is huge and is considered to be changing the way transactions are made in various domains. This tutorial has been prepared for professionals aspiring to learn the basics of Blockchain. We tried to explain Blockchain concepts through Bitcoin Crypto Currency. This course is going to give you great understanding for the students and professionals aspiring to make a career in the Blockchain technology.This tutorial will teach you blockchain technology, the driving force behind the cryptocurrency, Bitcoin. You will learn various aspects of cryptography, process of creating and chaining Blocks, Network & Mining and many other concepts associated with blockchain technology including designing of a blockchain network.
Blockchain Technology is the name given to a modern database management technique, which enables a large business to share information and communicate with the help of links and chains between different nodes in the network. It is a new way of handling digital transactions that have started to gain traction in recent years.
Data is kept in blocks that are connected in a chain within a blockchain database. Because the chain cannot be removed or altered without network approval, the data is consistent across time.
What is Blockchain?
A blockchain is an ever-growing ledger in a network, which keeps a track record of all transactions, changes and implementations that have taken place inside the network in a secure, ordered and immutable way. In simple terms, it is a chain of blocks like a linked list, with each node being before and after another node. All nodes or blocks have links to the next node, just like pointers in programming.


Each block records all of the recent transactions, and once completed goes into the blockchain as a permanent database. This technique is based on Cryptographic Concepts of Information Security, which will be studied later on. Each time a block gets completed, a new block is generated. Once a block of information is created in the chain, it can’t be changed or deleted. This makes the blockchain very secure and trustworthy.
A blockchain network is independent of centralized institutions, and it can work without any need for third-party middle-man such as central authorities, banks, government, etc. Transactions are verified by a network of computers. A blockchain network is based on the internet, and hence, it cannot run offline.
Key Takeaways
We can take the following important points from the above explanation, and memorize these before moving on to the next few sections −
* Blockchain represents a form of distributed database that contrasts with conventional databases in its method of information storage.
* It organizes data into blocks that are interconnected through cryptographic techniques, which will be studied later.
* A variety of information can be recorded on a blockchain, yet its primary application has been as a ledger for transactions.
* Blockchain operates in a decentralized manner, meaning that no individual or group possesses authority over it; control is shared among all users.
Elements of Blockchain
The key elements of any blockchain network include the following components given below −
Distributed Ledger
Every member of the network has the ability to reach the decentralized ledger and its unchangeable log of transactions. Through this common ledger, transactions are documented just one time, removing the need for redundant work that is common in conventional business networks.
Immutable Records
It is impossible for any participant to alter or manipulate a transaction once it has been documented on the shared ledger. In the event of an error in a transaction record, a new transaction must be created to correct the mistake, and both transactions will be transparently displayed.
Smart Contracts
To speed transactions, a set of rules that are called a smart contract is stored on the blockchain and run automatically. A smart contract defines conditions for corporate bond transfers, include terms for travel insurance to be paid and much more.
How Blockchain Work?
A blockchain consists of small sequenced programs, known as scripts, which conduct the tasks available in a database, like entering information, accessing data stored in the database, saving data and copying it elsewhere. By default, data once saved in a ledger cannot be altered. A blockchain is distributed, which means multiple copies are saved on many machines, and they must all match for it to be valid.
Transactions in a network follow a sequence of steps, which may differ depending on the type of network where they are implemented. Generally, when a transaction is initiated, the application that provides an interface for the blockchain starts a sequence of events.
Every node in the network proposes its own blocks in this way because they all choose different transactions. Each works on their own blocks, trying to find a solution to the difficulty target, using the query number used once, also called by its acronym nonce. Once a block is closed, a transaction is complete.
Although this process is a generalized sequence of steps, not all networks follow these in order, or at all. Some cryptocurrencies like Ethereum, Dogecoin, and Bitcoin are discussed in the later sections of this article.
Features of Blockchain
Blockchain technology is a major booming force for decentralized cryptocurrencies across the globe. Due to its many features, it finds use in various sectors of modern life. The following points briefly explain the features and concepts of Blockchain technology −
Decentralization
A blockchain facilitates the distribution of data across multiple network nodes—computers or devices operating blockchain software, located in different geographical areas. This architecture not only ensures redundancy, but also preserves the integrity of the data.
For instance, if an attempt is made to modify a record at one instance of the database, the other nodes will thwart this action by comparing block hashes. Consequently, no individual node within the network possesses the capability to alter information contained within the chain.
Transparency
Due to the decentralized structure of all blockchain networks, all transactions are openly accessible for viewing by downloading and examining them, or by utilizing blockchain explorers that enable real-time monitoring of transactions.
Every node maintains its own version of the chain, which is continuously updated with the addition of new blocks. Consequently, it is possible to trace the movement of a bitcoin to its destination, if desired.
Security
Blockchain technology ensures decentralized security and trust through various methods. Initially, new blocks are consistently stored in a linear and chronological manner, always being appended to the last of the blockchain. Once a block is added to the end of the blockchain, it becomes immutable, preventing any changes to previous blocks.
A modification in any data within a block alters its hash value. Since each block includes the hash of the previous block, any change would impact subsequent blocks. In the event of an attempt to modify a block, the network would reject it due to hash inconsistencies. Nevertheless, this manipulation can potentially occur in smaller blockchain networks.
Types of Blockchain Networks
There are a number of blockchain configurations, which can be explicitly classified into 4 subcategories. The following points clearly explain the different types of blockchain networks −
Public
Public blockchains are open to all participants, enabling anyone to become a member. Each individual within the blockchain possesses the same privileges to view, modify, and authenticate the blockchain.
The main purpose of public blockchains is for the trading and creation of digital currencies such as Bitcoin, Ethereum, and Litecoin.
Private
An individual entity oversees private blockchains, known as managed blockchains. The governing body dictates membership and privileges within the network.
Private blockchains exhibit partial decentralization due to their restricted access. Ripple, a digital currency exchange network catering to businesses, serves as a prime illustration of a private blockchain.
Consortium
Consortium blockchain networks are governed by a collective of organizations. These preselected entities collaborate to uphold the blockchain and establish protocols for data access. Sectors with aligned objectives and advantages in shared accountability typically favor consortium blockchain networks.
Hybrid
Hybrid blockchains integrate features from both private and public networks. Organizations have the capability to establish private, permissioned systems in conjunction with a public framework.
This arrangement enables them to manage access to particular data housed within the blockchain while maintaining the public availability of other information.
Smart contracts are employed to permit public participants to verify the completion of private transactions. For instance, hybrid blockchains can provide public access to digital currencies while ensuring that bank-owned currencies remain confidential.
Applications of Blockchain
Different sectors of industry use blockchain technology in a variety of ways. Some of these industries are mentioned below −
Energy Producing Industries
Energy companies leverage blockchain technology to establish peer-to-peer energy trading platforms, enhancing the accessibility of renewable energy. As an illustration, these applications include −
* Energy companies utilizing blockchain have developed a trading platform enabling individuals to buy and sell electricity. Homeowners equipped with solar panels can sell surplus solar energy to nearby residents through this platform. The system operates efficiently with smart meters initiating transactions, which are then recorded on the blockchain.
* Through blockchain-based crowd funding projects, users have the opportunity to sponsor and own solar panels in areas with limited energy resources. Upon the completion of solar panel installations, sponsors may also receive rental income from these communities.
Banking and Financial Organizations
Conventional financial institutions such as banks and stock exchanges leverage blockchain technology to oversee digital transactions, accounts, and market trading. One instance is the Singapore Exchange Limited, a company specializing in investment services across Asia, which utilizes blockchain to enhance interbank payment systems.
This adoption of blockchain has effectively addressed various issues, such as batch processing and manual reconciliation of a large number of financial transactions.
Entertainment Industry and Media
Media and entertainment companies utilize blockchain technology to oversee copyright information. Ensuring copyright validation is essential for ensuring artists receive fair compensation. Numerous transactions are required to document the purchase or transfer of copyright material.
Through the implementation of blockchain tactics, they have effectively enhanced efficiency and decreased expenses associated with copyright management.
Benefits (Pros) of Blockchain
The advantages (pros) of blockchain technology include the following points −
* Lower expenses by eradicating third-party verification
* Enhanced precision through the elimination of human verification
* Increased difficulty in tampering due to decentralization
* Secure, confidential, and effective transactions
* Clear and transparent technology
* Offers a banking substitute and a means to safeguard personal data for residents of nations with unstable or underdeveloped governments.
Drawbacks (Cons) of Blockchain
The drawbacks (cons) of blockchain technology include the following points −
* Limited number of transactions processed per second.
* Past involvement in illegal activities, like on the dark web.
* Uncertain and varying regulations across different jurisdictions.
* Restrictions on data storage capacity.
* Some blockchains come with a substantial technology cost.
Roadmap to Become a Blockchain Developer
The steps below include the exact steps to follow in order to get started with blockchain and become a blockchain developer. So, let’s dive into these steps one by one −
* Build a strong foundation of any programming language, syntax, object oriented programming (OOP) concepts and data structures, especially linked lists, graph and trees.
* Master at least one programming language like Python, JavaScript, or Solidity, which form the crux of blockchain development.
* Learn the core computer science subjects like Information and Network Security, Cryptography, Computer Networks and Database Management System (DBMS).
* Brush up mathematics topics like Probability, Statistics, Linear Algebra and Calculus.
* Start with Blockchain basics- Distributed Systems, Consensus Mechanisms (Proof of Work, Proof of Stake) ad Decentralized applications, called DApps.
* Explore different blockchain categories like Public, Private, Hybrid and Consortium.
* Master Smart Contracts and Solidity.
* Study cryptographic concepts like hashing, encryption, digital signatures, and key management.
* Choose a platform like Ethereum and its programming language Solidity. Practice writing, testing, and deploying smart contracts.
* Explore the Ethereum Ecosystem like Ethereum Virtual Machine (EVM). Start working on Web3 concepts in detail.
* Create projects and participate in hackathons and competitions to hone your skills in Web3 and Solidity.
* Explore more platforms apart from Ethereum, like Solana, Cordano and Polkadot and many more.
* Contribute to Open Source community and gain practical exposure in the field. Open source areas include the GSoC (Google Summer of Code) and many more.
FAQs about Blockchain
The following page answers the most frequently asked questions on Blockchain technology and cryptocurrency −
1. What are ledgers in Blockchain Networks?
Ledgers are continuously increasing data files, which log entries of all transactions of the network in which these are based.
2. What Languages are used in Blockchain Technology?
The main languages used for blockchain development are Solidity, Python, C#, Ruby, Golang and many more. It is preferred to use Solidity as a beginner.
3. Which are the Most used Cryptocurrencies in the World?
Bitcoin is the most used cryptocurrency in the world, followed by Ethereum and Dogecoin.
4. How does a Blockchain Work?
In general, many nodes within the same blockchain implementation are required to perform algorithms to evaluate, validate, and process the history of the blockchain block whenever a new blockchain transaction is added to the blockchain. The fresh block of blockchain transaction is accepted into the ledger and the new block containing data is added to the blockchain if the majority of nodes confirm the authenticity of the block’s history and signature.
Conclusion
The technology of blockchain is gaining significant recognition, largely due to the influence of Bitcoin and cryptocurrency, with numerous practical applications already being implemented and investigated. As a term frequently mentioned among investors nationwide, blockchain has the potential to enhance the accuracy, efficiency, security, and cost-effectiveness of business and government operations by reducing the need for intermediaries.
As we enter the third decade of blockchain, the focus has shifted from whether traditional companies will adopt this technology to when they will do so. Currently, we are witnessing a surge in non-fungible tokens (NFTs) and the tokenization of various assets. In the near future, we may observe an integration of multiple blockchains, tokens, and artificial intelligence into solutions for both businesses and consumers.
The concept of blockchain emerged with the creation of Bitcoin in 2008, followed by its practical application in 2009. Because Bitcoins from a major part of the history of Blockchain technology, it is crucial to mention Bitcoin, as the narrative of blockchain would be incomplete without it.
How did Blockchain Emerge?
We will now examine the foundational history of computing and computer networks, focusing on their evolution and the role they played in the emergence of Bitcoin in 2008. This analysis will be presented in chronological order −
* 1960s − The inception of computer networks
* 1969 − The establishment of ARPANET
* 1970s − Initial efforts in secure network communication, including the development of public key cryptography
* 1970s − The creation of cryptographic hash functions
* 1973 − The expansion of ARPANET to additional geographic regions
* 1974 − The introduction of the first internet service provider, Telenet
* 1976 − The Diffie–Hellman protocol for secure cryptographic key exchange
* 1978 − The advent of public key cryptography
* 1979 − The invention of Merkle Trees (a structure for organizing hashes) by Ralph C. Merkle
* 1980s − The advancement of TCP/IP protocols
* 1980 − The establishment of protocols for public key cryptosystems by Ralph C. Merkle
* 1982 − The proposal of blind signatures by David Chaum
* 1982 − The formulation of the Byzantine Generals Problem (Bitcoin can be viewed as a solution to this problem, although its primary aim was to resolve the double-spending issue)
* 1985 − The exploration of elliptic curve cryptography by Neal Koblitz and Victor Miller
* 1991 − The work of Haber and Stornetta on creating tamper-proof document timestamps, which can be seen as an early concept of blockchains or hash chains
* 1992 − The publication of "Pricing via Processing or Combatting Junk Mail" by Cynthia Dwork and Moni Naor, marking the first application of Proof of Work (PoW)
* 1993 − The enhancement of the tamper-proof document timestamp system with Merkle trees by Haber, Bayer, and Stornetta
* 1995 − The implementation of David Chaum's Digicash system (an anonymous electronic cash system) in select banks
* 1998 − The invention of Bit Gold by Nick Szabo, a decentralized digital currency mechanism utilizing hash chaining and Byzantine Quorums
* 1999 − The rise of Napster, a peer-to-peer file-sharing application primarily for music, which was centralized.
* 1999 − The creation of a secure timestamping service for the Belgian initiative TIMESEC.
* 2000 − The launch of the Gnutella file-sharing network, which pioneered the concept of decentralization.
* 2001 − The introduction of BitTorrent and Distributed Hash Tables (DHTs).
* 2002 − The development of Hashcash by Adam Back.
* 2004 − The conceptualization of B-Money by Wei Dei, which utilized hashcash.
* 2004 − Hal Finney's innovation of the reusable Proof of Work (PoW) system.
* 2005 − The implementation of computational puzzles to thwart Sybil attacks, as proposed by James Aspnes and colleagues.
* 2009 − The launch of Bitcoin, marking the inception of the first blockchain.
The technologies mentioned earlier played a significant role in the evolution of Bitcoin, even if their contributions were not direct; they are pertinent to the challenges that Bitcoin aimed to address.
Previous efforts to establish anonymous and decentralized digital currencies achieved varying degrees of success, yet they failed to completely resolve the issue of double spending in a fully trustless or permissionless setting. This challenge was ultimately overcome by the Bitcoin blockchain, which led to the creation of the Bitcoin cryptocurrency.
Additionally, it is important to recognize that concepts like state machine replication (the SMR problem), first introduced by Leslie Lamport in 1978 and later formalized by Fred Schneider in 1980, can also be addressed by Bitcoin. The Bitcoin network probabilistically resolves the SMR problem by facilitating block replication and maintaining consistency through its proof-of-work consensus mechanism.
Blockchain: What, When and How?
In 2008, a seminal paper titled "Bitcoin: A Peer-to-Peer Electronic Cash System" was authored under the pseudonym Satoshi Nakamoto, focusing on the concept of peer-to-peer electronic cash. This paper introduced the concept of a "chain of blocks," yet the true identity of Satoshi Nakamoto remains unknown.
Following the launch of Bitcoin in 2009, Nakamoto was actively involved in the Bitcoin development community until 2011, at which point he transferred control of Bitcoin's development to its core developers and vanished from public view. Since then, there has been no further communication from him, leaving his identity and existence enveloped in mystery. The phrase "chain of blocks" has since evolved into the term "blockchain."
As previously mentioned, blockchain technology encompasses a wide range of applications across various economic sectors. In particular, the finance sector has experienced notable enhancements in the efficiency of financial transactions and settlements, resulting in significant reductions in both time and costs.
Currently, it is important to recognize that many sectors of the economy have begun to acknowledge the potential and advantages of blockchain technology, and many are either already pursuing or will soon embark on initiatives to leverage its benefits.
The emergence of blockchain technology has completely transformed the landscape of data exchange, transactions, and digital trust. Since its inception in 2008, blockchain has gained significant attention across various industries due to its key features such as security, transparency, and decentralization.
Blockchain serves as a distributed ledger, securely storing data across a network of computers. This sets it apart from centralized systems, where information is stored in a single location controlled by a central authority. Operating on a decentralized network, blockchain enables every participant to have a copy of the entire ledger, eliminating the need for intermediaries and fostering digital trust among users.
While blockchain initially gained recognition as the foundation for Bitcoin, its applications extend far beyond cryptocurrencies. It has found uses in sectors such as healthcare, real estate, finance, supply chain management, and more. This chapter seeks to offer a comprehensive overview of blockchain technology and its potential to bring about transformative changes.
Rise of Blockchain Technology
One of the significant transformative technologies of the 21st century is blockchain. Blockchain is a technology that is poised to usher in a new way of conducting business that will change everyday life for the better. Blockchains are virtual, and therefore, they have no physical form.
The image above depicts a series of blocks, each containing data in the form of a distributed ledger. This serves as a database that can be shared among multiple devices or institutions, allowing for the sharing of information rather than copying or transferring it. The blocks within the ledger are organized in chronological order.
Blockchain is an ever-growing digital database that consists of a linked list of records. It contains sensitive information, such as financial transactions, which are safeguarded by cryptography and can be shared across a large, decentralized, and publicly accessible network. Each block in the chain includes a cryptographic hash of the previous block, a timestamp, and transaction data. This technology has emerged as a potential solution to the problem of declining trust in traditional institutions and online intermediaries, as it purportedly eliminates the need for trust between parties.
What is a Blockchain?
A blockchain functions as a decentralized and distributed ledger that securely records transactions across multiple computers, preventing retroactive alterations. This technology is widely utilized in finance, supply chain management, and various other industries due to its ability to provide transparent and secure record-keeping.
In essence, a blockchain serves as a digital ledger for tracking transactions and data, akin to a personal notebook for recording daily expenses. This ledger is accessible to many individuals, allowing for visibility and contributions from all participants, similar to a shared notebook among friends. Transactions are permanently recorded in the ledger, with very blockchain participant possessing a copy, ensuring the integrity of past transactions.
The absence of a central authority, like a bank, eliminates the need for centralized transaction monitoring, enhancing security, transparency, and fairness within the system. Essentially, a blockchain acts as a digital ledger for securely tracking transactions and data, shared among a network of participants, resembling a communal bulletin board for posting messages and monitoring contributions.
Centralized Vs. Decentralized Vs. Distributed Architecture








Centralized System
	Decentralized System
	Distributed System
	All data and processing power is stored and managed by a single central authority.
	The system is spread across multiple nodes, but there is still a central authority that manages and makes decisions for the system as a whole.
	The system is spread across multiple nodes and there is no central authority controlling the system.
	There is a single point of control, and communication is centralized through a central node.
	Multiple nodes communicate with each other, but the central authority remains in control.
	Each node communicates with other nodes and collaborates to make decisions for the system as a whole.
	Centralized networks are typically the most costeffective options for small systems and require fewer resources to set up and maintain.
	Decentralized networks improve user request speed by establishing local master nodes in high traffic areas, rather than routing to a central server.
	Distributed networks offer robustness with node failure as computational workload is rebalanced among remaining nodes. They are more robust than other network architectures.
	Easier to standardized interactions between the main server and client nodes. That can lead to a more consistent and streamlined end user experience.
	Since decentralized networks do not have a single point of failure, they can continue to operate even if a master node is compromised or shut down.
	Distributed networks are more scalable than both centralized and decentralized networks. They generally exhibit lower latency as well due to the even distribution of network processing power and data.
	Centralized networks are characterized by well-defined command structures, which facilitate easy delegation and minimize communication overlap across different authorization levels. The process of adding or removing client nodes is also uncomplicated.
	Decentralized networks speed up user requests by having local master nodes in high traffic areas, instead of routing to a central server over large distances.
	In a distributed network, data is evenly shared and harder to modify, censor, or destroy, making the network more transparent. This is often further secured through cryptography.
	Simplified Architecture of Blockchain
Blockchain represents a decentralized and distributed ledger that encompasses various transaction types organized within a peer-to-peer network. This network comprises numerous computers, each contributing to the collective agreement necessary to prevent unauthorized modifications of data.
The architecture of blockchain technology is characterized by a sequence of blocks, each housing a collection of transactions arranged in a specific order. These blocks may be maintained as a flat file or within a straightforward database. Two fundamental data structures employed in blockchain technology are pointers and linked lists, which are crucial for maintaining the integrity and immutability of the data within the blockchain network.
A concise overview of pointers and linked lists is as follows −
* Pointers are variables that hold information about the location of another variable, effectively indicating its position.
* Linked lists consist of a series of blocks arranged in a defined order, with each block containing particular data and linked to the subsequent block via a pointer
Key Characteristics of Blockchain Architecture
The blockchain architecture provides various advantages to businesses. Some of its primary features include −
* Cryptography − Blockchain transactions are verified and reliable thanks to the intricate calculations and cryptographic evidence among the parties involved.
* Immutability − Any data stored in a blockchain cannot be altered or removed.
* Provenance − This refers to the ability to trace the origin of every transaction within the blockchain ledger.
* Decentralization − Every member of the blockchain framework has access to the entire distributed database. Unlike a centralized system, the consensus algorithm enables network control.
* Anonymity − Each participant in the blockchain network has a unique address, rather than a user identity, ensuring user anonymity, particularly in a public blockchain structure.
* Transparency − The blockchain system is highly resistant to corruption, as it would require significant computing power to completely overwrite the blockchain network.
Key Factors of a Blockchain Networks
Various essential factors that influence the working of blockchain architecture include −
* Distributed structure − The distributed nature of a blockchain network is a key characteristic. It eliminates the necessity for a central authority and enables multiple nodes to engage in the network and verify transactions.
* Blocks − A block is a data unit that comprises a group of transactions, a timestamp, and a reference to the previous block, also referred to as a hash. This forms a chain of blocks, hence the term blockchain.
* Nodes − Nodes are the computers or devices that take part in the blockchain network. Each node retains a copy of the entire blockchain and aids in validating transactions and generating new blocks.
* Consensus mechanism − To ensure data integrity, the network employs a consensus mechanism. This enables nodes to agree on transaction validity and helps prevent unauthorized modifications to the blockchain by malicious actors.
* Public/private keys − Public and private keys are utilized to create a digital signature for each transaction. The public key encrypts the data, while the private key decrypts it.
* Hashes − A hash is a crucial element of blockchain technology, serving as the foundation of its secure architecture. Essentially, a hash is a unique representation of data generated through a cryptographic hash function. It functions as a digital fingerprint for each block in the blockchain, offering a secure and immutable means to identify and trace the block.
* Chain of blocks − The hash of a block is connected to the hash of the preceding block, forming a chain of blocks that establishes the core of a blockchain’s architecture.
* Proof-of-work − This mechanism makes it challenging for anyone to alter the information stored in a blockchain. It entails a computational work process that must be executed to append a new block to the chain, rendering it time-consuming and resource-intensive.
* Block formation of transactions − Within a blockchain network, transactions are compiled into blocks. Each block is characterized by a timestamp, a reference to the preceding block (commonly referred to as a hash), and a collection of transactions. This structure results in a sequential chain of blocks, which is the essence of blockchain technology.
* Node verification − The nodes within a blockchain network play a pivotal role in validating transactions and incorporating new blocks into the blockchain. For instance, when a user intends to transfer funds to another individual, the transaction must undergo verification by the network's nodes prior to its inclusion in the blockchain.
* Role of cryptography − Cryptography serves as a fundamental component of blockchain architecture, ensuring the security of the data contained within the blockchain. Each block and transaction is subject to encryption, and a digital signature is employed to confirm its authenticity. Public and private keys facilitate the creation of a digital signature for each transaction, with the public key utilized for data encryption and the private key for decryption.
* Crypto tokens − These digital assets are tradable on a blockchain and are frequently employed to motivate nodes to validate new blocks.
* Smart contracts − A significant feature of blockchain architecture is the implementation of smart contracts. These self-executing contracts automatically enforce the terms of an agreement when specific conditions are satisfied. This functionality removes the necessity for intermediaries, thereby enhancing the efficiency and transparency of the blockchain network. For example, a smart contract can facilitate the automatic transfer of funds from one user to another upon the fulfillment of a predetermined condition, such as the successful completion of a project.
Types of Blockchain Networks
There are mainly three types of blockchain networks that have evolved from conventional and traditional network based system based on decentralization. These networks are as follows −
* Private Blockchain
* Consortium Blockchain
* Hybrid Blockchain
1. Private Blockchain
A private blockchain is a specific type of blockchain technology that is limited to a particular group of participants and is commonly utilized by organizations and institutions for internal operations. It operates as a permissioned blockchain, meaning it is controlled by a single entity. Unlike public blockchains, private blockchains are not open-source, and only authorized individuals can access the network. This allows for effective blockchain usage while restricting access to selected participants.
Organizations can establish various parameters for the network, such as accessibility, authorization, and more. Transactions on private blockchains are typically faster and more secure, although they lack the transparency and decentralization of public blockchains. Private blockchains are more scalable when compared to other factors. Permissioned blockchains do not adhere to a decentralized theoretical nature.
Some blockchain platforms are built on private blockchains, and while many consider private blockchains as permissioned blockchains, the concept of permissioned blockchains can encompass public blockchains as well. Due to the limited number of nodes in private blockchains, security may be compromised if a certain number of nodes become malicious and disrupt the consensus mechanism of the network.
2. Consortium Blockchains
Consortium blockchains represent a blend of public and private blockchain characteristics, aimed at harnessing the advantages of both systems.
Also referred to as federated blockchains, consortium blockchains offer an innovative solution for organizations that require features from both public and private blockchains. In this model, certain elements of the organizations are accessible to the public, while others are kept confidential. The governance of consortium blockchains is shared among a collective of organizations, rather than being dominated by a single entity or a small group of individuals. These blockchains are particularly prevalent in sectors such as finance, where participating organizations seek a secure and transparent network while retaining a degree of control over its operations.
To ensure effective functioning, a consortium blockchain typically incorporates a validator node tasked with two primary responsibilities: validating transactions and either initiating or receiving them. In contrast, member nodes within the network are restricted to either initiating or receiving transactions. This structure allows consortium blockchains to provide the advantages of a private blockchain, such as transparency, privacy, and efficiency, without allowing any single participant to wield excessive power or control over the network. By distributing authority and accountability among multiple entities, consortium blockchains achieve an optimal balance of security, flexibility, and accessibility, making them suitable for a variety of applications and use cases.
3. Hybrid Blockchain
Hybrid blockchain is the final type of blockchain that will be discussed in this context. Hybrid blockchain may appear similar to a consortium blockchain, but it is distinct. Nevertheless, there are potential similarities between the two. A hybrid blockchain is characterized as a fusion of a private and public blockchain. This particular blockchain type enables organizations to capitalize on the advantages of both private and public blockchains, providing an optimal solution for their specific requirements.
Operating within a closed ecosystem, a hybrid blockchain grants organizations the necessary control and privacy, while still enabling interaction with a public network. An illustration of a hybrid blockchain includes Dragonchain and XinFin, which present a distinctive solution for organizations seeking a blend of benefits. Through the integration of the privacy and control of a private blockchain with the transparency and accessibility of a public blockchain, organizations can enhance their operations in terms of efficiency and security.
Blockchain Vs. DLT
DLT and blockchain are frequently used interchangeably, but they are not exactly the same. While both are designed to address the same issue of securely and efficiently sharing information and data among multiple parties, DLT is a broader term that encompasses other technologies, whereas blockchain is a specific type of DLT.
Although both are related, they have distinct differences that set them apart. Here is a comparison between DLT and blockchain −
Blockchain
* Blockchain is a type of DLT that establishes an open and transparent ledger of transactions.
* It utilizes a series of blocks linked together with cryptography to form a growing list of records, known as blocks.
* Each block has a unique hash, a timestamp, and transaction information.
* This creates a secure and transparent ledger of transactions that is maintained by a network of nodes and is difficult to alter.
DLT
* DLT is a digital system that shares information and data across a network of nodes.
* It is a term that encompasses various technologies, including blockchain, that enable secure and efficient data sharing among multiple parties.
* DLT is commonly used for financial transactions and utilizes cryptography to maintain the security of the information on the ledger.
What is Cryptography in Blockchain?
Cryptography is a growing phenomenon in the realm of modern data security and efficient information exchange. Cryptography represents the age-old pursuit of secure communication. It has evolved from ancient cryptic manuscripts to the complex algorithms of modern science and technology.
This chapter will delve into the interconnected disciplines of cryptography and encryption. In addition to exploring the histories and complexities of this technology, we will also gain insight into routes, keys, mechanisms and many more concepts.
Routes of Cryptography
Traces of cryptography can be found far back in history, when simple encryption methods like ciphers were utilized for securing important information. Encrypting messages used to be an enjoyable activity during childhood, often involving swapping messages with close friends. Many people have employed various techniques to keep their messages private, such as using invisible ink or wax seals. The need to conceal messages has existed since the transition from primitive living to organized societies and the development of civilization. As different groups and tribes emerged, competition arose, leading to hierarchical aggression, covert communication, and manipulation of the masses. The earliest forms of encryption were discovered in regions associated with the birthplace of civilization, including Egypt, Greece, and Rome.
Ancient Egypt is credited with the earliest known form of cryptography, using hieroglyphs to encode sensitive information. Over time, different encryption methods have been employed, including substitution ciphers, transposition ciphers, and polyalphabetic ciphers.
The Caesar cipher, named after Julius Caesar, a Roman military general from 100 BCE who utilized it to secure his military communications, is one of the simplest and oldest known substitution ciphers. The Vigenère cipher and the Playfair cipher, developed in the 16th and 19th centuries respectively, are examples of polyalphabetic ciphers. However, these traditional encryption techniques are no longer considered secure for safeguarding sensitive data, as they can be easily deciphered by modern computers.
Types of Ciphers
There are two types of ciphers which are most commonly used in the field of cryptography and cybersecurity, which are as follows −
* Monoalphabetic Cipher
* Polyalphabetic Cipher
1. Monoalphabetic Cipher
In a monoalphabetic cipher, every letter in a message is consistently swapped with a single= letter. For example, in a Caesar cipher, each occurrence of the letter A could always be transformed into a G, resulting in a straightforward pattern. Due to the simplicity of this technique, these ciphers are prone to techniques like frequency analysis, where the occurrence of letters in the encoded message is calculated to decipher the encryption.
In this type of cipher, each letter in the original message is shifted by a fixed number of positions in the alphabet.
For instance, with a shift of 2, the following alterations can be observed −
* Original − HEY
* Encrypted − JGA
In this scenario, every letter is substituted with the letter that is two positions ahead in the alphabet.
2. Polyalphabetic Cipher
On the contrary, a polyalphabetic cipher increases complexity by employing various substitutions for the same letter based on a confidential key.
An illustration of this is the Vigenère cipher, where each letter in the key corresponds to a distinct shift in the alphabet. This dynamic substitution enhances the complexity for cryptanalysts to decode the message, offering better protection in comparison to monoalphabetic ciphers.
The term "poly" means "many", indicating numerous methods of encrypting each letter, hence adding an additional layer of security to the encoded message. Within this cipher, a keyword is utilized to establish multiple shift values for every letter.
For instance −
* Original − TRUST
* Key − KEY
* Encrypted − DVSCX
In the above example, the key is repeated till the length of the word, hence TRUST->KEYKE. Then, we refer to the corresponding values of each row and column from the table to encrypt the message. Hence, under row T and column K, we get D. Similarly, under row R and column E, we get V, and so on.
Basic Terms of Cryptography
Before deep diving into related concepts and further links of cryptography. Let us step out and familiarize ourselves with a few basic concepts and terminologies −
* Encryption − The process of converting plaintext into ciphertext, making it unreadable to unauthorized parties.
* Decryption − The act of deciphering the encoded message (ciphertext) back to its original form (plaintext) so that it can be read and understood by those who are authorized to do so.
* Cipher − The algorithm used for encryption and decryption.
* Key − A private value utilized in combination with an encryption algorithm to scramble and unscramble information.
* Symmetric Key − A solitary private key utilized for both the procedures of encoding and decoding.
* Asymmetric Key − A pair of keys, one for encryption and one for decryption, that are mathematically related but not identical.
* Plaintext − The original, unencrypted data.
* Ciphertext − The encrypted data.
* Hash Function − A one-way function that takes an input (or message) and returns a fixed-size string of characters, which is typically a digest that is unique to the unique message.
* Digital Signature − A digital code that is attached to an electronically transmitted document to verify its contents and the sender’s identity.
* Public Key Infrastructure (PKI) − A collection of hardware, software, individuals, protocols, and protocols necessary for the establishment, administration, dissemination, utilization, storage, and revocation of digital certificates.
* Certificate Authority (CA) − An organization that issues digital certificates and manages the PKI.
* Non-repudiation − The ability to prove that a specific individual was responsible for a particular action or message.
* Authentication − The process of verifying the identity of an individual or entity.
* Key Management − The process of creating, distributing, storing, and protecting keys.
We will be looking at the above concepts in detail in the coming sections of this tutorial.
Principles of Cryptography
Cryptography is the technique of securing information by converting it into a code that can only be read by those who are permitted to do so. The core ideas and rules of cryptography encompass −
* Confidentiality − Ensuring that confidential information is protected from those who are not authorized to access it.
* Integrity − The information is sensitive so its nature should not be tampered with or altered in any way.
* Authentication − Confirming the identity of the sender and receiver of the packet of information.
* Non-repudiation − Ensuring that the sender of the info cannot deny the origin of the content.
* Key Management − Managing the generation, distribution, storage, and use of keys for encryption and decryption in a secure manner.
* Algorithms − Algorithms are math functions that help secure information by converting it into an unreadable form and making it readable again through decryption.
* Public Key Cryptography − Public key cryptography involves using a publicly accessible key to encrypt data and a privately held key to decrypt it. On the other hand, symmetric key cryptography employs a single secret key to encrypt and decrypt data.
* Hash Functions − Mathematical functions that take an input (or message) and produce a fixed-length output, used to confirm the integrity of the original message
We will delve into these topics extensively as we progress forward. These notions and precepts are put into practice in diverse encryption techniques, including symmetric-key encryption, asymmetric-key encryption, and hash functions.
Types of Cryptography
There are mainly two types of cryptography used in modern networks and communication systems −
* Public Key Cryptography
* Elliptic Curve Cryptography
1. Public Key Cryptography
Public key cryptography utilizes a set of keys, with one being public (accessible to all) and the other private (known solely by the owner).
Let us take an example of two people- Alice and Bob. Alice wants to send a message to Bob but in a secure way. In order to transmit a message to Bob, Alice employs Bob's public key for encryption. Bob, in possession of his private key, is able to decrypt and access the message.
This works in the following way −
* Encryption − Bob’s public key is like a special lock, and Alice uses it to lock her message.
* Decryption − Bob’s private key is like the unique key that opens the lock to read the message.
2. Elliptic Curve Cryptography
ECC is a powerful and innovative encryption method, revolutionizing the modern cryptographic techniques. It enhances security while requiring smaller key sizes compared to traditional cryptographic algorithms. Let us learn different aspects of ECC.
Key Generation
Public Key (Q) − Bob picks a curve and a point on it. He calls this point (G). His public key (Q) is a result of multiplying (G) by a secret number (d).
Example − Q = d . G
Encryption
* When Alice wants to send Bob a secret message, she picks a random number (k).
* She computes a point (C) on the curve by multiplying (G) by (k).
* The x-coordinate of (C) is part of the encrypted message.
* The shared secret is derived by Bob multiplying (C) by his secret number (d).
* Example − s = k . Q
Decryption
* Bob, with his private key, multiplies (C) by (d) to get the same shared secret (s).
* Using a key derivation function, both Alice and Bob derive a symmetric key from (s).
* The symmetric key is used to decrypt the message.
* Example − S = d . C
Concept of blockchain emerged with the creation of Bitcoin(Crypto) in 2008. Because Bitcoins from a major part of the history of Blockchain technology. But as time goes companies like Google, Apple, Porche, Coca-Cola, and IBM define the use cases of Blockchain beyond the Crypto.
Blockchain Technology Timeline
Since Blockchain was introduced till now there are so much progression in this time period. As you can see on the image as we described each phases of Blockchain.
Exploration & Investment
Blockchain in 2015 represents a frontier technology with immense potential but significant risks. While Crypto (Bitcoin) has shown resilience and growth, the emergence of platforms like Ethereum suggests a broadening of blockchain applications beyond digital currency. Investors and developers was entering the space and focused on blockchain education.
Early Adoption
The early adoption stage of blockchain technology began around 2016 where most people unaware about this powerful technology, a few of us start using this technology to create small scalable projects. Lack of community support and knowledge all we were using this on cryptos.
Growth
The growth stage, which we've been experiencing in recent years from 2018 to till now by using this technology on finance, supply chain, healthcare, etc. Governments and financial institutions start developing regulatory frameworks. Increased venture capital funding and corporate investments in blockchain projects.
Maturity
The maturity stage will be in the upcoming years, which we're gradually moving towards, is expected to include Interoperability, Standardization, Scalability solutions, Sustainable practices, Education and workforce and Integration with other technologies.
Blockchain Use Cases Beyond Crypto
Banking
There are nemours use cases of blockchain in banking sector not just the replacing the physical currency. Blockchain can be used for Fraud Detection and KYC.
* Fraud Detection: Reduced fraud in affiliate programs.
* KYC: Avail KYC virtually that saves time.
Cybersecurity
In cybersecurity blockchain provide decentralized data storage, improved authentication process by using cryptographic signatures, making harder to alter data undetected. Improved integrity verification for software updates and patches.
IoT
Playing an important role in IoT by securing device-to-device communication and decentralized network architecture for better scalability. Also helps in tamper-proof logs of device activities and data exchanges.
Healthcare
In the healthcare industries enhanced patient data privacy and control that helps to give right treatment to the patient at the right time. That reduce the failure rate of treatment.
Supply Chain
In supply chain end-to-end traceability of products helps to helps to keep the track. Also Reduced counterfeiting through verifiable product histories using smart contracts for automated payments and inventory management.
Encrypted Messaging
In this era, nothing on the internet is entirely secure. To protect confidential information, blockchain technology can be used to encrypt messages between two or more people. This encryption ensures that third parties cannot decrypt the conversation.
Pharmaceuticals
Pharmaceuticals companies using the large amount of data to sell the medicine to the right patient by using blockchain technology.
Advertisement
To detect your right audience you need a large data where you can use Blockchain to place your advertisement. It helps to create direct connections between advertisers and publishers, reducing intermediaries.
Affiliate Marketing
Affiliate Marketing becomes transparent and immutable tracking of referrals and sales. Avail to detect smart contracts for automatic, accurate commission payouts. Generate direct trustless relationships between merchants and affiliates.
Other Popular Use Cases of Blockchain
* Unified Communication: A lot of companies are using automated communications, this can be enhanced by Blockchain to keep it bi-directional and relatable.
* Government: Governments are using Blockchains to improve the service quality like safeguard the citizens property and cut the red tape by keeping the transparency in the system.
* Charities: People were scared to donate on charities, as where his money will be used there was no transparency. By using Blockchain now there is transparency.
* Ride-Sharing Economy: By using Blockchain in ride-sharing economy it gives the control to riders and drivers. Uber is using the same concept with the Blockchain.
* Elimination of Counterfeit Products: De Beers diamond producer using Blockchain to keep the record of registered diamond to reduce the conflict of diamond transaction.
* Contracts: Blockchain can the check contract rule, verify and process the transaction without any involvement by using Smart Contact Blockchain design.
* Microloans: Blockchain technology can easily approve microloans and credited the amount to the appliers' account instantly. There are a lot companies which are using Blockchain to approve microloans like Paytm, Phonpe, Twigga, etc.


The advanced blockchain concepts contain topics like the CAP theorem, consensus in blockchain, cryptographic primitives, data structures in blockchain, block and block header. These concepts are to be understood after completing the basic concepts and terminologies of blockchain technology and cryptography.
CAP Theorem: What and how?
The CAP theorem is frequently discussed in the context of blockchain technology. This theorem highlights that a distributed system can only achieve two out of the three desired characteristics: consistency, availability, and partition tolerance. It asserts that it is impossible for a distributed system to simultaneously provide all three guarantees: consistency, availability, and partition tolerance. The C, A, and P in CAP stand for −
* Consistency − All users must see the same information at the same time, regardless of the computer they are using. To achieve this, any information added to one computer must be immediately sent to all other computers in the system for storage.
* Availability − Users should receive a response when requesting information, even if some computers are not functioning. Every computer in the system should respond to any request made.
* Partition Tolerance − If a connection between two computers is lost, it is considered a partition. Partition tolerance ensures that the system continues to operate even if there are issues with connections between computers.
In the context of blockchain systems, the CAP theorem is significant as it helps in understanding the compromises that need to be made during blockchain design. For instance, prioritizing consistency may result in reduced availability or weaker handling of network partitions. Conversely, prioritizing availability and partition tolerance may impact consistency.
What is Byzantine General's Problem?
The consensus mechanism plays a vital role in any blockchain architecture, as it guarantees the preservation of trust, agreement, and security within a decentralized network of computers. One of the primary challenges that consensus mechanisms address is the Byzantine generals problem, which pertains to achieving consensus in a distributed system. Various consensus mechanisms are available, each presenting its own set of benefits and drawbacks. Commonly utilized mechanisms include proof of work (PoW), proof of stake (PoS), delegated proof of stake (DPoS), and practical Byzantine fault tolerance (PBFT). The choice of a consensus mechanism is influenced by the specific needs of the blockchain network and the necessary trade-offs among security, scalability, and energy efficiency.
The Byzantine generals problem, derived from a historical scenario involving the Byzantine army, is a computer science dilemma concerning the attainment of consensus in a decentralized environment where some participants may exhibit faults or malicious behavior. In such scenarios, ensuring that all nodes agree on a specific matter, such as the value of a transaction within a blockchain, becomes complex, especially when certain nodes may provide misleading or contradictory information. The lack of secure communication channels introduces the risk of a single point of failure, known as a Byzantine fault, where components may malfunction, and there is uncertainty regarding whether a component has indeed failed.
A blockchain seeks to address this issue by establishing a layer of trust that does not require trust in every individual. Miners and validators play a crucial role in this system. Their objective is to add new entries to the ledger by following the rules of the game. One common consensus mechanism used to tackle the Byzantine generals problem is PoW. In PoW, network nodes compete to solve a cryptographic puzzle, with the first successful node adding the next block to the chain. Subsequently, other nodes validate this block, and upon reaching a consensus on its validity, add it to their ledger. This process ensures a decentralized and secure method of achieving consensus on the system's status.
Another prevalent consensus mechanism is PoS. In PoS, nodes are selected to validate transactions based on the cryptocurrency they hold and are willing to stake as collateral. This setup incentivizes nodes to act honestly, as any malicious behavior could result in the loss of their staked funds.
PBFT functions as a consensus mechanism utilizing a consensus protocol to determine the next block to be appended to the blockchain. Through communication between nodes, agreement is reached, and a node is only permitted to add a block to the blockchain upon receiving sufficient votes from other nodes within the network.
Consensus Mechanism
Blockchain consensus is the process by which peers in a network agree on the current state of the data. It is a critical mechanism in decentralized systems, providing trust and security for secure and confidential transactions. Without consensus, conflicting transactions would not be prevented, making it essential for the functioning of cryptocurrency blockchains. Various types of consensus mechanisms exist, each with different energy usage, security, and scalability, but all share the common goal of ensuring the integrity of records.
Here is an outline of some of the most well-known consensus mechanisms utilized by distributed systems to achieve consensus −
* PoW is the original consensus mechanism and was utilized by cryptocurrencies like Bitcoin and Ethereum. Miners compete to solve complex mathematical puzzles, and the first to solve the puzzle is permitted to create a new block and validate transactions. The successful miner is also rewarded with cryptocurrency known as a block reward. PoW is considered a secure and reliable mechanism but requires substantial computational resources and energy, resulting in high operating costs and environmental impact.
* PoS is a more environmentally-friendly alternative to PoW. In PoS, miners pledge a stake of cryptocurrency and are randomly selected to validate transactions. The more cryptocurrency a miner holds, the higher their chances of being selected. The system favors entities with a higher number of tokens, leading to centralization concerns.
* DPoS is a variation of PoS where the network users vote to select witnesses to secure the network on their behalf. Only the top tier of witnesses with the most votes can validate blockchain transactions. The witnesses are incentivized to remain honest by being at risk of being replaced by those deemed more trustworthy.
* Proof of activity (PoA) is a hybrid of PoW and PoS, used by the Decred and Espers blockchain projects. The mining process starts like PoW, with miners competing to solve a mathematical problem, then switches to PoS where validators are selected to sign off on the block header. The block rewards are shared between the miner and validators. PoA has been criticized for its energy-intensive mining phase and its partiality towards validators holding a greater number of coins.
* Proof of Authority (PoA) differs from PoS as it selects validators based on their reputation rather than staking cryptocurrency. This approach requires minimal computing power and is more resource-efficient, but it has faced criticism for its potential to concentrate power among a small number of authoritative nodes.
Cryptographic Primitives
The various categories of cryptographic primitives include the following −
* One-way Hash Functions − These are mathematical algorithms that accept a message and generate a fixed-length string of numbers known as the hash or digest. They ensure the integrity of digital data by preventing alterations. It is important to note that even a minor modification in the input can lead to a completely different hash output, a phenomenon referred to as the avalanche effect. A widely used hash function is SHA-256.
* Symmetric Ciphers − When a message is encrypted with a key, it is transformed into ciphertext, which appears readable yet lacks meaning. The same key is employed to revert the ciphertext to its original message. A key serves as a variable for both encryption and decryption, acting as a mechanism to secure or release data. Notable examples of key-based encryption algorithms include AES, DES, and Blowfish. While symmetric encryption typically offers quicker processing speeds than public-key cryptography, the challenge lies in the secure sharing of keys.
* Asymmetric Ciphers − These utilize a pair of keys, one for encrypting information (the public key) and another for decrypting it (the private key). Examples include RSA, DSA, and elliptic curve cryptography.
* Block Ciphers − These encrypt data in fixed-size blocks, such as 64 or 128 bits. They are frequently combined with hash functions to ensure the security of lengthy messages.
* Stream Ciphers − These encrypt data one bit or byte at a time, making them particularly effective for protecting real-time information such as audio or video streams.
* Digital Signatures − These provide a method to verify the authenticity of a digital message or information, confirming that it originates from the claimed sender. They employ asymmetric ciphers to create a signature that can be validated using the sender’s public key.
* Message Authentication Codes − These are similar to digital signatures but use symmetric ciphers to make a code that can be checked using the same secret key used to make it.
Data Structures used in Blockchain
Blockchain technology utilizes several fundamental data structures that are essential for its security and operational efficiency. At its core, a blockchain consists of two primary data structures: blocks and a linked list. The various categories of blocks include −
* The majority of blocks are designed to extend the existing primary blockchain, which is recognized as the longest chain within the network. These are termed main branch blocks.
* Conversely, some blocks may link to a parent block that is not part of the longest blockchain, and these are referred to as side branch blocks.
* Furthermore, there are blocks that connect to a parent block that is not recognized by the node processing the block; these are classified as orphan blocks.
A new block is generated in a blockchain by linking it to the preceding block via a unique identifier known as a hash. This new block contains the hash of the previous block, the new transaction details, and a random number referred to as a nonce. A block is incorporated into the blockchain only after all network computers have validated the transaction. This validation process is crucial as it ensures the transaction is permanent and immutable, a fundamental characteristic of blockchain technology. The data within the block is compressed through a method called hashing to minimize its size. Each block encompasses all confirmed transactions for a specific time frame. As additional blocks are appended, they collectively form a chain known as a blockchain, which is the structural basis for the security of the blockchain.
Features of a Blockchain
Each block within the blockchain is structured uniquely, consisting of various key components −
* Header − This section of a block contains essential metadata, such as the block's distinct identifier (block hash), a timestamp, and the hash of the preceding block in the chain. This connection between blocks forms a continuous chain.
* Transactions − Multiple transactions can be found within a block, representing the transfer of digital assets from one user to another. These transactions undergo processing and verification by network participants (nodes) before being appended to the block.
* Merkle Tree Root − To streamline the verification process of transactions within a block, a Merkle tree is utilized. This binary tree data structure enables efficient and secure verification of large data sets.
* Nonce − Miners use a nonce, a random number, to solve the cryptographic puzzle required for adding a block to the blockchain. The nonce, when combined with other block header data, generates a hash that meets the network's difficulty criteria.
* Difficulty Target − This value sets the level of difficulty for adding a new block to the blockchain. The difficulty is adjusted regularly to maintain a consistent block creation rate and prevent an overflow of blocks within the blockchain.
Header Hash and Height of Block
The blocks within a blockchain require a form of identification to distinguish them from one another. Two key parameters are utilized for this purpose −
The block header hash serves as a unique identifier, generated by hashing the block header within a blockchain. This cryptographic hashing process is performed twice, resulting in a value that encapsulates essential details about the block. These details include the timestamp of block addition, reference to the previous block, Merkle tree root summarizing transactions, random number for mining, and the difficulty target for mining. The hash is produced using a cryptographic function, ensuring that any modifications to the block header will yield a distinct hash. This hash is not stored within the block's data during transmission or within the blockchain on certain nodes.
The second parameter for block identification is its height, denoting the block's position within the blockchain. Starting from zero for the genesis block, the block height increments by one for each subsequent block. This metric is crucial for maintaining chronological order within the blockchain and determining the sequence of blocks.
Genesis Block
The initial block of a blockchain is referred to as the genesis block. This first block is of great significance, as it signifies the start of the blockchain and serves as the basis for all subsequent blocks. The genesis block of Bitcoin and other cryptocurrencies is the very first block that was mined on their respective networks. Each block within the blockchain contains information related to transactions on the network and is distinguished by a unique header. However, the genesis block differs from all other blocks in that it does not have a preceding block. It typically includes specific data, such as a timestamp and message, which is used to kickstart the blockchain.
The creation of the genesis block is a crucial moment in the development of a blockchain, as it establishes the network’s fundamental rules and characteristics. These rules, such as block size and mining rewards, are set in stone once the genesis block is created and cannot be changed. As the first block of the blockchain, the genesis block also plays a vital role in shaping the narrative of the network’s origins.
The decentralized nature of the Bitcoin network is one of its key features, meaning that there is no intermediary between users and the network. To ensure the validity of transactions on the network, complex mathematical problems are utilized, which are solved by computers known as Bitcoin miners. Miners are unable to trade Bitcoins until they have completely solved the mathematical puzzle. Furthermore, all transactions on the Bitcoin network are permanently recorded, making it impossible to conceal any evidence of illicit activity.
Linking of Blocks
The process of linking blocks within a blockchain is crucial for maintaining the security and integrity of the system. Each block comprises data pertaining to transactions and is connected to its predecessor through a reference known as the previous block hash. The data contained within the blocks is immutable and can be verified. These blocks are organized sequentially, forming a chain to ensure their proper arrangement. This reference functions similarly to a fingerprint, aiding in the preservation of the order of the blocks.
To generate this reference, the information within the block header undergoes a cryptographic transformation. This transformation employs a mathematical algorithm to create a unique identifier, referred to as the hash. Any alteration in the block header will result in a change to the hash, allowing other network participants to easily detect any modifications. The chain is established through cryptographic techniques, with each block containing a unique code, or hash, that connects it to the preceding block. Additionally, the hash records the timestamp of when the block was incorporated into the blockchain. Should any information within a block be modified, the hash will differ, thereby disrupting the continuity of the chain.
Merkel Tree
A Merkle tree, also known as a hash tree, is a data structure where each leaf node represents a cryptographic hash of a single data block, while each non-leaf node represents a cryptographic hash of the hashes of its child nodes. This type of tree is commonly utilized for validating transactions within a blockchain network and is highly efficient in doing so. The majority of Merkle trees follow a binary structure, with each node having only two child nodes, although some may have multiple child nodes. In the field of computer science, Merkle trees are a widely adopted form of data structure that can effectively summarize all transactions in a block through a series of hash computations.
In a Merkle tree, transactions are arranged into leaf nodes, with each leaf node containing the hash of a single transaction. The hashes of the leaf nodes are then paired and hashed again to produce a set of intermediate nodes. This process is iterated until a single hash, referred to as the Merkle root, is generated.
The Merkle root serves as a straightforward mathematical technique for verifying the information within a Merkle tree. It is included in the block header and serves as a concise summary of all transactions within the block. When a new block is appended to the blockchain, its Merkle root is incorporated into the hash of the preceding block, establishing a connection between the two blocks.
To comprehend the functioning of a Merkle tree, let us examine a straightforward illustration: Suppose there are four transactions, denoted as A, B, C, and D, within a single block. Each transaction is then transformed into a distinct string of characters (hash): Hash A, Hash B, Hash C, and Hash D. These hashes are then paired to create two new hashes: Hash AB and Hash CD.
Ultimately, these two hashes are merged to produce the Merkle root, which is Hash ABCD. Although this example simplifies the concept of a Merkle tree, the actual structure is considerably more intricate, particularly when each transaction possesses a 64-character long ID. Nonetheless, this example imparts a fundamental understanding of the algorithm's operation and its efficacy. A Merkle tree can be utilized to effectively oversee and authenticate the eligibility of participants for exclusive sales or events. The following is a detailed explanation −
Generating unique identifiers
Each participant, or potential buyer, is allocated a unique identifier, such as their Ethereum wallet address or any other distinct identifier linked to their account.
Establishing a whitelist
The organizer of the NFT sale formulates a whitelist containing the unique identifiers of participants qualified for the exclusive event. This whitelist essentially comprises a roster of addresses permitted to partake.
Hashing participant identifiers
The unique identifiers (addresses) of participants are individually hashed. This can be accomplished using a hash function (e.g., SHA-256), resulting in a hash for each identifier.
Constructing the Merkle tree
The hashed identifiers are structured into a Merkle tree format. The Merkle tree is built by pairing and hashing the individual hashes until a solitary root hash is derived.
Announcing the Merkle root
The organizer discloses the root hash of the Merkle tree. This hash functions as a succinct and secure representation of the entire whitelist.
Participant verification
Participants interested in the NFT sale can check their eligibility by hashing their identifier and comparing it to the published Merkle root. If the hash matches, the participant is on the whitelist.
Efficient verification process
Verifying eligibility through the Merkle tree is computationally efficient. Participants do not need to reveal their identifier; they only need to present the hashed value. This ensures privacy while allowing efficient validation.
Event Access
During the NFT sale or event, only participants with identifiers on the whitelist (matching the Merkle root) are granted access. This creates an exclusive environment for whitelisted participants
Decentralization is a well-established concept that has been implemented in strategy, management, and government for an extended period. The fundamental principle of decentralization involves sharing control and power with the outer regions of an organization rather than having one central entity solely in-charge. This structure offers numerous advantages to organizations, including improved efficiency, quicker decision-making processes, enhanced motivation, and decreased pressure on senior management.
What is Decentralization in Blockchain?
Decentralization is a fundamental advantage and feature offered by blockchain technology. The design of blockchain enables it to serve as a platform that eliminates the need for intermediaries, and can operate with multiple leaders selected through consensus mechanisms. This structure permits individuals to vote for the position of decision-making authority. The competition is overseen by a consensus mechanism, with the most well-known being Proof of Work (PoW).
The extent of decentralization ranges from a partially decentralized model to a fully decentralized one, depending on the specific requirements and circumstances. From a blockchain standpoint, decentralization can be seen as a tool that allows for the transformation of existing application, or the creation of new applications, in order to grant users complete control.
Types of Networks Systems
Traditionally, information and communication technology (ICT) has been centralized, with database or application servers controlled by a central entity, such as a system administrator. However, with the emergence of Bitcoin and blockchain technology, this model has shifted. Now, technology exists that enables anyone to establish and operate a decentralized system without a single point of failure or a sole trusted authority. The decentralized application running on the blockchain can function autonomously or with some level of human intervention, depending on the governance type and model in place.
The main network systems that exist in today’s fintech industries are as follows −
* Centralized Network
* Decentralized Network
* Distributed Network
These networks are explained in detail in the following paragraphs −
1. Centralized Systems
Centralized Systems, also known as traditional IT systems, are characterized by a single authority overseeing all operations and services. Users depend on this central source for all their needs, a model adopted by major online service providers such as Google, Amazon, eBay, and Apple's App Store.
2. Decentralized Systems
In Decentralized Systems, control is not centralized to one main node but is instead distributed among multiple nodes on a network. This setup is similar to organizations where each department manages its own database server, reducing the central server's authority and empowering sub-departments to handle their databases.
3. Distributed Systems
Distributed Systems involve the distribution of data and computation across various nodes within a network. While often confused with parallel computing, the key distinction lies in the fact that parallel computing systems perform computations simultaneously across all nodes to achieve results. This approach is commonly used in weather research, simulations, and financial modelling.
Methods of Decentralization
Two methods can be used to achieve decentralization: disintermediation and competition. These methods will be discussed in detail in the sections that follow −
Disintermediation
The concept of disintermediation can be elucidated through an example. Consider the scenario where you intend to transfer money to a friend in a different country. Traditionally, you would approach a bank, which, in exchange for a fee, would facilitate the transfer to the recipient's bank in the other country. The bank acts as an intermediary by maintaining a centralized database that records and confirms the transaction. However, with the utilization of blockchain technology, it becomes feasible to directly transfer the money to your friend without the involvement of a bank. All that is required is your friend's blockchain address.
By bypassing the intermediary, disintermediation is achieved, leading to decentralization. This disintermediation model is not limited to the financial sector but can also be applied across various industries such as healthcare, legal, and public services.
Contest-Driven Decentralization
It involves a competitive approach where multiple service providers vie for the opportunity to offer services within a system. While this method does not achieve complete decentralization, it does prevent any single intermediary or service provider from monopolizing the service. In the context of blockchain technology, a system can be envisioned where smart contracts autonomously select an external data provider from a pool of providers based on factors such as reputation, past performance, reviews, and service quality.
Although this approach may not lead to absolute decentralization, it empowers smart contracts to make independent choices based on the specified criteria.
Pertinent Terminology
The subsequent ideas are noteworthy in the context of decentralization. The terminology presented here is frequently used while pertaining to decentralization and its implementations.
Smart Contracts
A smart contract is a software program typically operating on a blockchain. While smart contracts do not necessarily require a blockchain to function, the security advantages provided by blockchain technology have made it a standard decentralized execution platform for smart contracts.
Smart contracts generally encompass business logic and a limited amount of data. The business logic is executed when specific criteria are met. These smart contracts are utilized by actors or participants in the blockchain, or they operate autonomously on behalf of the network participants.
Autonomous Agents
An Autonomous Agent (AA) is an artificially intelligent software entity that acts on behalf of its owner to accomplish certain objectives without necessitating significant intervention from its owner.
Decentralized Organizations
Decentralized Organizations (DOs) are software programs running on a blockchain and are founded on the concept of real organizations with individuals and protocols. Once a DO is incorporated into the blockchain in the form of a smart contract or a series of smart contracts, it becomes decentralized, and parties interact with each other based on the code defined within the DO software.
Decentralized Autonomous Organizations
Decentralized Autonomous Organizations (DAOs) operate as computer programs on blockchain technology, encompassing governance and business logic rules within their structure. Unlike DOs, DAOs are fully automated and incorporate artificial intelligence, distinguishing them from their human-dependent counterparts.
Ethereum blockchain pioneered the concept of DAOs, where the code itself governs the organization instead of traditional human or contractual oversight. Despite their autonomous nature, DAOs may still have human curators overseeing the code and evaluating proposals from the community, ensuring a balance between automation and human involvement. Additionally, DAOs have the ability to engage external contractors based on input from token holders, enhancing their operational capabilities.
Decentralized Corporations and Societies
Decentralized Autonomous Corporations
DACs are often seen as a subset of DAOs, sharing a similar concept. While their definitions may overlap, the key difference lies in the fact that DAOs are typically nonprofit, whereas DACs can generate profits through shares distributed to participants who may receive dividends.
With the ability to operate autonomously based on pre-programmed logic, DACs can effectively run a business without the need for human intervention.
Decentralized Autonomous Societies
DASes represent a unique concept where an entire society operates on a blockchain using a combination of complex smart contracts, DAOs, and DApps. This model does not advocate for a completely unregulated approach, nor is it solely based on libertarian principles. Instead, essential government services like identity card systems, passports, and records of deeds, marriages, and births can be efficiently managed through blockchain technology.
In cases where traditional systems fail to provide the necessary trust, societies have the option to establish their own virtual governance on a blockchain, driven by decentralized consensus and transparency. While this idea may seem like a dream for libertarians or cypherpunks, it is a feasible reality within the realm of blockchain technology.
Decentralized applications, commonly referred to as dApps, are software solutions that operate on a blockchain or a peer-to-peer (P2P) network of computers, rather than being hosted on a single machine. Unlike traditional applications that are governed by a central authority, dApps are distributed across the network, allowing users to collectively manage and control them.
DAOs, DACs, and DOs are decentralized applications (DApps) that operate on a blockchain within a peer-to-peer network. They signify the forefront of advancements in decentralization technology.
On the other hand, Decentralized Finance, also referred to by it’s acronym DeFi, uses bockchain technology to eliminate intermediaries and centralized entities from financial transactions. It encompasses cryptocurrencies, blockchain technology, and software that enable peer-to-peer financial transactions. However, DeFi is currently vulnerable to security breaches due to inadequate programming and insufficient security testing during application development.
Let us first discuss a bit about the DApps and their types. The concepts of DeFi are explained in further parts of this chapter.
Types of Decentralized Applications (D-Apps)
At their core, DApps are software applications that function through one of several methods. They are classified into three categories −
* Type 1
* Type 2
* Type 3
These types of DApps are explained in detail in the following sections −
Type 1
Operate on their own dedicated blockchain, such as standard smart contract-based decentralized applications (DApps) that function on the Ethereum network. When necessary, they utilize a native token, such as ETH on the Ethereum blockchain.
An example of this is Ethlance, a DApp that leverages ETH to facilitate a job marketplace.
Type 2
Rely on an established blockchain, meaning they utilize the infrastructure of Type 1 blockchains while incorporating custom protocols and tokens. An example of this is smart contract-based tokenization DApps that operate on the Ethereum blockchain.
A notable instance of Type 2 DApps is the OMNI network, which serves as a software layer built on top of the Bitcoin to enable the trading of custom digital assets and currencies.
Type 3
Employ the protocols associated with Type 2 DApps.
For instance, the SAFE Network utilizes the OMNI network protocol.
Requirements of a Decentralized Applications (D-Apps)
To qualify as a decentralized application or DApp, certain regulations must be fulfilled. This definition was articulated in an article by Johnston et al. in 2015, titled The General Theory of Decentralized Applications, or DApps −
* The DApp must be entirely open source and operate autonomously, ensuring that no single entity possesses control over a majority of its tokens. Modifications to the application should be driven by consensus, reflecting the input from the community.
* The data and operational records of the application must be secured through cryptographic means and stored on a public, decentralized blockchain to eliminate any central points of failure.
* The application must utilize a cryptographic token to facilitate access and incentivize contributions from users, such as miners in the Bitcoin network.
* If tokens are utilized, they must be generated by the decentralized application through a consensus mechanism and a relevant cryptographic algorithm. This token generation serves as evidence of the value provided by contributors, such as miners.
In general, DApps now offer a wide array of services, encompassing financial applications, gaming, social media, and healthcare, among others.
Functions of Decentralized Applications (D-Apps)
The establishment of consensus within a decentralized application (DApp) can be accomplished through the implementation of consensus algorithms, including Proof of Work (PoW) and Proof of Stake (PoS).
To date, PoW has demonstrated remarkable resilience against attacks, as evidenced by the widespread success and trust associated with the Bitcoin network. Additionally, a DApp has the capability to distribute tokens (coins) through various means such as mining, fundraising, and development initiatives.
How are Decentralized Applications (D-Apps) Developed?
Traditional applications typically comprise a user interface, along with a web server or an application server, and a backend database, representing a standard client/server architecture.
In contrast, a decentralized application (DApp) utilizes a blockchain as its backend, which works on most of the logic behind the actual computations of DApps. A crucial component in the development of a DApp is the smart contract, which operates on the blockchain and incorporates the necessary business logic.
It is important to note that the frontend in both DApp and traditional application architectures can take the form of a thick client, a mobile application, or a web frontend (a web user interface, UI). However, it is most often a web frontend, typically developed using a JavaScript framework such as React or Angular.
Example of Decentralized Applications (D-Apps)
Some of the most popular example of DApps are given as follows −
* KYC-Chain
* OpenBazaar
* Lazooz
Let us look at a brief explanation of each of these −
1. KYC-Chain
This application provides the facility to manage Know Your Customer (KYC) data securely and conveniently based on smart contracts.
2. OpenBazaar
It is a decentralized platform that facilitates direct transactions between sellers and buyers without the need for intermediaries like eBay or Amazon.
Unlike traditional e-commerce platforms, OpenBazaar does not rely on a blockchain but utilizes distributed hash tables in a peer-to-peer network for communication and data sharing. Payments on OpenBazaar can be made using Bitcoin or other cryptocurrencies.
3. Lazooz
This is the decentralized equivalent of Uber. It allows peer-to-peer ride sharing and users to be incentivized by proof of movement, and they can earn Zooz coins.
Decentralized Web
The concept of a decentralized web refers to a vision where no central authority or group of authorities holds control. Initially, the Internet was designed to be decentralized, with open protocols like HTTP, SMTP, and DNS enabling anyone to freely utilize them and join the Internet.
However, the introduction of the Web layer above these protocols shifted towards a more service-oriented structure, leading to the dominance of profit-driven corporations like Facebook, Google, Twitter, and Amazon. While these companies offer valuable services, they have created a more controlled, centralized, and closed system.
The rise of these commercial giants has raised significant concerns regarding privacy and data protection, as they have monopolized the Internet. Despite their efficiency and popularity, these business models pose a threat to privacy and decentralization due to the limited number of entities controlling the online landscape.
Web 3.0
Web 1.0 or Web 1 is the original World Wide Web, which was developed in 1989. This was the era when static web pages were hosted on servers and usually only allowed read actions from a user's point of view.
On the other hand, Web 2.0 is the era when more service-oriented and web-hosted applications started to emerge. E-commerce websites, social networking, and applications were the main features of this period.
Web 3.0 or Web 3 represents the concept of a decentralized internet or web that will transform the way we interact with the internet today. This marks a new era that prioritizes users and operates in a decentralized manner, free from the control of any single authority, large organization, or internet company.
Example of Web 3
Examples of Web 3 include −
Steemit
A social media platform built on the Steem blockchain and STEEM cryptocurrency. Users are rewarded with cryptocurrency for their contributions, with more tokens earned based on the number of votes received.
Status
A decentralized communication platform offering secure and private messaging services.
IPFS
A peer-to-peer hypermedia/storage protocol enabling decentralized storage and sharing of data across a peer-to-peer network.
Decentralized Identity
Decentralized identity has recently become a popular trend. The issue of identity is a sensitive and complex one to address. Currently, the identity of a user is often not under the control of the identity holder due to the dominance of large Internet companies and similar organizations, leading to privacy concerns. Decentralized identity aims to give control of identity credentials back to the identity holders, allowing them to determine when and how they share their credentials and with whom.
A notable example of this is Microsoft's development of a decentralized identity network called Identity Overlay Network (ION) on the Bitcoin blockchain. This infrastructure is built on the work done for decentralized identity at W3C and the Decentralized Identity Foundation.
IBM and other organizations worldwide have also undertaken similar initiatives.
DeFi stands for decentralized finance, representing a new wave of blockchain applications that offer innovative solutions to conventional financial services. This emerging sector has already showcased various successful use cases, such as online transactions and digital asset trading, highlighting the transformative power of blockchain technology in the financial industry.
The integration of blockchain technology in finance has gained significant traction with the rise of DeFi platforms.
Advantages of Decentralized Finance (DeFi)
Let’s discuss some advantages of DeFi in detail −
Human Errors
Financial crises often stem from mismanagement by central banks and third-party intermediaries. Smart contracts, however, offer a solution by eliminating the potential for human error in daily operations, unless the contracts are poorly drafted.
Immutability
The inability to alter blockchain records due to immutability ensures the security of the network. Alongside decentralization, immutability plays a crucial role in safeguarding the integrity of DeFi systems during financial transactions.
Transparency
DeFi's transparency is a key feature, allowing anyone to view blockchain data at any time. This openness, combined with immutability, enhances the trustworthiness of the system.
Tokens
Tokenization has become a prominent concept in the blockchain community, with Ethereum offering robust smart contract capabilities for issuing crypto tokens.
Disadvantages of Decentralized Finance (DeFi)
Let’s discuss some disadvantages of DeFi in detail −
Scalability
DeFi projects undoubtedly have the potential to enhance financial inclusion for a broader audience. However, these initiatives encounter significant challenges related to the scalability of the underlying blockchain.
The lengthy confirmation times for DeFi transactions present a considerable obstacle.
Liquidity
Liquidity is a critical factor that must be addressed in blockchain-based projects and protocols. The total value locked (TVL) across all DeFi initiatives is approximately one billion dollars.
It is not surprising that the decentralized finance market remains considerably smaller than traditional financial systems.
Shared Responsibility
One notable aspect of DeFi is the shared responsibility users have in maintaining the network, which can lead to potential issues. DeFi projects do not assume liability for any mistakes made by participants.
Their primary function is to eliminate intermediaries, placing the responsibility on users to manage their own funds and assets.
Applications of Decentralized Finance (DeFi)
Decentralized Finance finds its applications in a wide range of areas like banking, financial institutions, shareholdings and many more. Let us explore these areas in detail in the next section −
* DeFi has many use cases, such as loans, decentralized exchanges (DEXs), derivatives, payments, insurance, and assets. All these uses share the absence of a central authority, allowing DeFi platform users to conduct business directly with each other, without any intermediaries involved.
* The DeFi revolution is currently underway, with over a billion dollars' worth of value locked in the DeFi system. This substantial amount of locked value clearly indicates the significant usage of DeFi applications, which is expected to continue growing.
* Other emerging trends include the integration of various technologies with blockchain, creating new opportunities for innovation in areas such as artificial intelligence and the Internet of Things (IoT).
The landscape of blockchain technology is evolving swiftly, and its influence on our daily business operations will persist as new advancements arise. This innovation has disrupted traditional business models and offers significant advantages, including cost reduction, enhanced efficiency, and increased transparency.
We have delved into the foundational aspects of blockchain technology, examining elements such as cryptography, consensus algorithms, and the principles of distributed systems. Our exploration has included cryptocurrencies like Bitcoin and Ethereum, along with the development of smart contracts and decentralized applications (DApps).
Moving forward, we will investigate the most recent advancements, emerging trends, challenges, and future forecasts concerning blockchain technology. Additionally, we will address various topics related to ongoing research challenges and potential enhancements in the blockchain domain.
Emerging Trends of Blockchain
The realm of blockchain technology is experiencing a major shift and rapid progress, fueled by strong interest from both academic and business sectors. As the technology matures, several key trends are emerging.
One prominent trend is the growing emphasis on private blockchains, which have garnered significant interest for their customized applications in financial institutions.
Moreover, enterprise blockchains are being designed to provide solutions that meet the efficiency, security, and integration requirements of large organizations.
New Ideas of Blockchain
Since the advent of Bitcoin, there has been a swift emergence of new blockchains. Below, we will outline some of the latest trends −
Application-Specific Blockchains
There is a noticeable trend towards the development of application-specific blockchains (ASBCs). These blockchains are either custom-built or utilize existing blockchain platforms, tailored for a singular application and aimed at a particular industry.
For instance, Everledger is a blockchain solution designed specifically to provide an immutable tracing history and audit trail for diamonds and other high-value assets.
Another example of an ASBC is the Digital Trade Chain (DTC), where a consortium of seven banks has come together to streamline the trade finance process by directly linking the parties involved in trade transactions.
Alternatives to Blockchains
As blockchain technology has evolved in recent years, researchers have begun exploring the potential for creating platforms that can offer the same guarantees and services as blockchains, but without relying on traditional blockchain structures.
This exploration has led to the creation of R3's Corda, which deviates from the typical blockchain model by not utilizing blocks to contain transactions. Instead, it operates on the principle of a state object that moves through the Corda network, adhering to the specific requirements and rules set by the network participants, thereby reflecting the most current state of the network.
Additionally, IOTA serves as another example; it is an IoT-focused distributed ledger that employs a Directed Acyclic Graph (DAG) known as Tangle, rather than a standard blockchain composed of sequential blocks.
Blockchain as a Service
As cloud platforms continue to mature, numerous companies have begun offering Blockchain as a Service (BaaS).
Notable examples include Microsoft's Azure, which offers the Ethereum blockchain as a service, and IBM's Cloud platform, featuring IBM's own blockchain service. This trend is anticipated to expand in the coming years, with an increasing number of companies likely to enter the BaaS market.
Additionally, Electronic Government as a Service (eGaaS), a specific variant of BaaS, delivers tailored blockchains designed for governance-related applications.
New Programming Languages
The emergence of new programming languages is gaining traction, particularly in the realm of smart contract development. Current initiatives are increasingly centered around domain-specific languages, such as Solidity for Ethereum and Pact for Kadena.
This marks the beginning of a trend, and it is anticipated that numerous additional languages will be created as technology continues to evolve.
Cryptoeconomics
The advent of blockchain technology has given rise to new research domains, particularly cryptoeconomics, which focuses on the protocols that regulate the decentralized digital economy.
As blockchain and cryptocurrency technologies evolve, so too does the body of research in this field. Vitalik Buterin has characterized cryptoeconomics as an interdisciplinary study that integrates mathematics, cryptography, economics, and game theory.
What the Future Holds of Blockchain?
The year 2019 marked a significant transition from theoretical Proof of Concept (PoC) phases to the establishment of actual blockchain environments. It was widely recognized as the year of enterprise blockchain, with expectations that numerous organizations would embark on comprehensive enterprise blockchain initiatives.
A notable instance of mainstream tokenization is found in Decentralized Finance (DeFi), which currently holds billions of dollars in value within its ecosystem. This technology is anticipated to expand further in the coming years.
The following forecasts are expected to materialize between 2020 and 2050 −
* The Internet of Things (IoT) will operate across various blockchains, leading to the emergence of a machine-to-machine (M2M) economy, encompassing energy devices, autonomous vehicles, and smart home appliances.
* Digital currencies issued by central banks will become commonplace, with their integration into daily transactions anticipated within the next two to five years.
* DeFi is expected to undergo regulation, becoming an integral part of standard financial operations, with hundreds of billions of dollars locked within its ecosystem.
* Medical records will be securely shared while maintaining patient confidentiality among different private blockchains managed by a consortium of healthcare providers.
* Elections and voting processes will be conducted transparently and securely through decentralized web applications that utilize blockchain technology as their foundation.
* Financial institutions will implement numerous private blockchains to facilitate data sharing among participants and to streamline internal operations.
A smart contract is a robust and autonomous computer program that embodies an agreement, capable of being executed and enforced automatically. It indicates that a smart contract is essentially a program crafted in a language comprehensible to a computer or designated machine.
It also represents agreements between parties through business logic. A key aspect is that smart contracts execute automatically based on the coded instructions, such as when specific conditions are met. They are enforceable, meaning that all terms of the contract are carried out as intended, even in the face of opposition.
What is Enforcement in Smart Contracts?
Enforcement here is a comprehensive term that includes traditional legal enforcement, as well as the application of specific measures and controls that facilitate the execution of contract terms without the need for external intervention. Ideally, smart contracts should operate independently of conventional enforcement methods.
They should adhere to the principle that code serves as the law, eliminating the necessity for an arbitrator or third party to oversee, control, or influence the execution of a smart contract. Unlike traditional contracts, smart contracts are self-enforcing rather than legally enforceable. While this concept may seem like an idealistic vision, it is entirely feasible and aligns with the fundamental essence of smart contracts.
How did Smart Contracts Emerge?
In the 1990s, Nick Szabo introduced the concept of smart contracts in his article titled "Formalizing and Securing Relationships on Public Networks." This idea emerged nearly two decades prior to the widespread recognition of the potential and advantages of smart contracts, which came about with the creation of Bitcoin and the later emergence of more sophisticated blockchain platforms like Ethereum.
Szabo defines smart contracts as follows −
"A smart contract is an electronic transaction protocol that executes the terms of a contract. The general objectives are to satisfy common contractual conditions (such as payment terms, liens, confidentiality, and even enforcement), minimize exceptions both malicious and accidental, and minimize the need for trusted intermediaries. Related economic goals include lowering fraud loss, arbitrations and enforcement costs, and other transaction costs."
The functionality of smart contracts was first implemented in a limited manner with Bitcoin in 2009. Bitcoin features a constrained scripting language known as script, which facilitates the transfer of bitcoins between users. However, this language is not complete and does not allow for the development of arbitrary programs. It can be likened to a basic calculator that performs simple arithmetic, while smart contracts function as general-purpose computers capable of executing any program.
Features of Smart Contracts
A smart contract possesses several key characteristics, which are mentioned as follows −
* Self-Performing − It operates autonomously on a blockchain without the need for external intervention.
* Enforceable: All terms of the contract are automatically upheld.
* Secure − Smart contracts are designed to be tamper-proof or resistant, benefiting from the security assurances provided by the underlying blockchain. However, the programming language and the code of the smart contract must also be accurate, valid, and verified.
* Consistent and Efficient − This feature guarantees that a smart contract will consistently yield the same result for a given input. While this can be seen as part of the security aspect, highlighting it separately emphasizes its significance.
* Syntactically sound − Smart contracts are constructed to be complete and meaningful for both humans and machines.
* Resilient and Durable − They are resilient against adversarial actions or adverse conditions, ensuring that once initiated, smart contracts execute their functions deterministically within a defined timeframe.
Example Usage of a Smart Contract
Let us take an example of a financial contract. It may not necessarily require semantic clarity and immutability; however, it must be capable of automatic execution, enforceability, determinism, and security.
Conversely, a title deed must possess semantic integrity and completeness. Consequently, for it to function effectively as a smart contract, the language used must be comprehensible to both humans and machines.
Ricardian contracts were first introduced in Ian Grigg's paper, "Financial Cryptography in 7 Layers," during the late 1990s. These contracts were originally implemented in a bond trading and payment system known as Ricardo.
The core concept of a Ricardian contract is to create a document that is comprehensible and recognized by both legal authorities and computer systems. They tackle the problem of value issuance on the internet, by clearly identifying the issuer and detailing all terms and conditions within a document, thereby ensuring its validity as a legally enforceable contract.
Features of Ricardian Contracts
A Ricardian contract is characterized by several key features −
* It is a contract presented by an issuer to its holders.
* It represents a valuable entitlement for holders, overseen by the issuer.
* It is designed for easy comprehension by individuals (similar to a traditional paper contract).
* It is structured for programmatic readability (parsable, akin to a database).
* It includes a digital signature.
* It contains keys and server details.
* It is associated with a distinct and secure identifier.
Ricardian Contracts - Bowtie Model
In practice, the execution of contracts involves the creation of a single document that encapsulates the contractual terms in legal language along with the necessary machine-readable tags. This document is digitally signed by the issuer utilizing their private key.
Subsequently, it undergoes hashing through a message digest function, generating a unique hash that serves as an identifier for the document. This hash is then utilized and signed by the involved parties during the contract's execution, linking each transaction to the identifier hash, thereby providing evidence of intent.
This process is illustrated in the accompanying diagram, commonly referred to as a Bowtie Model.
The diagram includes several components, which are explained in the following section −
* The World of Law is depicted on the left side, indicating the origin of the document. This document is a legally written contract accompanied by machine-readable tags.
* Following this, the document is hashed.
* The resulting message digest acts as an identifier within the World of Accountancy.
Ricardian Contracts - World of Accountancy
The World of Accountancy encompasses all accounting, trading, and information systems utilized in business operations. The concept behind this flow is that the message digest produced from hashing the document is initially employed in a genesis transaction, or the first transaction.
After this, it serves as an identifier for all transactions throughout the contract's operational execution. This establishes a secure connection between the original written contract and each transaction within the World of Accountancy.
Ricardian Contracts - Types of Semantics
The semantics of a Ricardian Contract can be categorized into two distinct types −
Operational Semantics
These refer to the actual execution, correctness, and safety of the contract, while denotational semantics focuses on the real-world implications of the entire contract. Some scholars have drawn a distinction between smart contract code and smart legal contracts, suggesting that a smart contract primarily addresses the execution aspect of the agreement.
Denotational Semantics
These semantics encompasses both the denotational and operational aspects of a legal agreement. While it may be logical to classify smart contracts based on these semantic differences, it is more advantageous to view a smart contract as an independent entity capable of encapsulating both legal language and code (business logic).
Ricardian Contract Vs. Smart Contracts
A Ricardian contract differs from a smart contract in that the latter does not involve any formal contract, and is primarily focused on executing the terms of the agreement. In contrast, a Ricardian contract emphasizes the creation of a document that incorporates legal language and semantic depth.


This distinction is clearly illustrated in the following section −
Feature
	Ricardian Contract
	Smart Contract
	Focus
	Human-readable and understandable legal document
	Automatic execution and enforcement of contract terms
	Strength
	Clear communication of contract terms, serves as legal record
	Efficient and reliable performance of contractual obligations
	Representation
	Combination of natural language (prose), computer-readable code, and parameters
	Code written in a specific programming language
	

Let us take an example of Bitcoin Technology.
In the context of Bitcoin, one can observe a basic implementation of smart contracts that utilize conditional logic, which is solely aimed at the execution and fulfillment of the contract.
Conversely, a Ricardian contract is designed to produce a document that is comprehensible to humans while also containing elements that can be interpreted by computer programs.
Blockchain Oracles play a crucial role in the ecosystem of smart contracts and blockchain technology. One of the main limitations of smart contracts is their inability to access external data, as blockchains operate as closed systems without direct links to real-world information.
This external data may be necessary for executing specific business logic within the smart contract, such as the stock price of a financial asset needed to trigger dividend distributions.
In these cases, oracles serve as a solution by supplying the required external data to smart contracts. An oracle can be described as an interface that facilitates the transfer of data from outside sources to smart contracts. These oracles are reliable entities that utilize secure channels to convey off-chain information to the smart contract.
Blockchain Oracles Applications
Oracles can provide various types of data based on the specific requirements of different industries and use cases. This data can include weather information, current events, corporate actions, and information sourced from Internet of Things (IoT) devices.
For instance, within a Bitcoin blockchain, an oracle has the capability to input data into a particular transaction, while a smart contract can observe that transaction on the blockchain and retrieve the data.
Additionally, another approach involves storing the acquired data within a smart contract's storage, allowing other smart contracts on the blockchain to access it through inter-contract requests, depending on the platform.
In the case of Ethereum, this can be accomplished through the use of message calls.
How Blockchain Oracles Work?
The fundamental operation of oracles is outlined as follows −
* A smart contract initiates a data request to an oracle.
* The oracle processes this request and retrieves the necessary data from the designated source. Various techniques can be employed to obtain this data, including utilizing APIs from the data provider, accessing a web service, querying a database , or extracting information from another blockchain.
* The retrieved data is forwarded to a notary, which generates cryptographic proof to verify the data's validity. TLSNotary is commonly used for this purpose. Other methods may include Android proofs, Ledger proofs, and proofs supported by trusted hardware.
* The data, along with its validity proof, is then sent to the oracle.
* Optionally, the data and its authenticity proof can be stored in a decentralized storage system like Swarm or IPFS, allowing the smart contract or blockchain to access it for verification.
* Ultimately, the data, accompanied by its validity proof, is delivered to the smart contract.
Types of Blockchain Oracles
Generally, oracles can be divided into two main categories: inbound oracles and outbound oracles. The subsequent section will dive deeper into these classifications.
Inbound Oracles
This category encompasses oracles that gather data from external sources and input it into smart contracts. We will briefly explore software, hardware, and other types of inbound oracles in the coming sections.
Outbound oracles
These are referred to as reverse oracles, facilitate the transmission of data from blockchain smart contracts to external environments.
There are two primary scenarios for their use. The first involves a source blockchain generating data, such as blockchain metrics, that is required by another blockchain. In this case, the relevant data must be communicated to a smart contract on the receiving blockchain. The second scenario entails an external hardware device executing a physical action triggered by an on-chain transaction.
Types of Inbound Oracles
The following sections shed light on the major types of Inbound Oracles available in Blockchain Oracle Technology −
Software Oracles
These oracles are tasked with gathering information from various online services available on the Internet. Typically, they are employed to obtain data such as meteorological conditions, financial statistics (like stock prices), travel details, and other information from external providers.
Hardware Oracles
This category of oracle is utilized to collect data from hardware sources, including IoT devices and sensors. This is particularly beneficial in scenarios like insurance-related smart contracts, where telemetry sensors can provide critical information such as vehicle speed and location.
Computation Oracles
These oracles facilitate the execution of computation-heavy tasks off-chain. Since blockchain technology is not ideal for handling resource-intensive calculations, a smart contract on a blockchain can request these computations to be carried out on external high-performance computing systems, receiving the verified results back through an oracle.
Aggregation-Based Oracles
In this model, a single value is derived from multiple data feeds. For instance, when determining the price of a financial asset, relying on a single source can be risky. To address this, various data providers are utilized, and the price reported by the majority of these feeds is selected to ensure accuracy.
Crowd Wisdom-Driven Oracles
This approach tackles the blockchain oracle issue by avoiding reliance on a single source that may not be trustworthy. Instead, it leverages multiple public sources to derive the most accurate data through collective input.
Decentralized Oracle
This category of oracle is designed using a distributed framework. It is also possible for these oracles to source data from other blockchains that operate on a distributed consensus model, thereby guaranteeing the integrity of the information.
Smart Oracles
Smart oracles function similarly to traditional oracles but possess the additional functionality of executing contract code. The smart oracles developed by Codius operate within Google Native Client, a secure environment designed for executing untrusted x86 native code.
Blockchain Oracle Services
A variety of online platforms now offer oracle services, often referred to as oracle-as-a-service solutions. These services are designed to facilitate the secure acquisition of off-chain data necessary for smart contracts to execute and make informed decisions.
Notable examples include −
* Town Crier − https://www.town-crier.org
* Provable − https://provable.xyz
* Witnet − https://witnet.io
* Chainlink − https://chain.link
* The Realitio project − https://realit.io
* TrueBit − https://truebit.io
* iExec − https://iex.ec
Additionally, the platform at https://smartcontract.com/ allows for the creation of oracles for Ethereum, Bitcoin, and Town Crier, enabling smart contracts to interface with applications and incorporate data from off-chain sources.
The Decentralized Autonomous Organization (DAO), which was launched in April 2016, functioned as a smart contract designed to facilitate investment opportunities. The principle that "code is law" or the concept of immutable smart contracts should be approached with caution, as the execution of these ideas has not yet reached a level of maturity that warrants absolute trust.
This concern became apparent following the DAO incident of hacking into the system, when the Ethereum foundation intervened to halt and modify the DAO's operations by implementing a hard fork in the Ethereum blockchain.
Although this hard fork was enacted for legitimate reasons, it contradicts the fundamental principles of decentralization, immutability, and the belief that code governs all. In response to this hard fork, a faction of users chose to continue mining on the original chain, leading to the establishment of Ethereum Classic. This version of the blockchain remains the original, unaltered Ethereum that still encompasses the DAO, reinforcing the idea that on this chain, code remains the ultimate authority.
History of Decentralized Autonomous Organization (DAO)
In June 2016, a vulnerability known as the reentrancy bug in the code led to a significant breach, resulting in the theft of approximately 3.6 million ether, equivalent to around 50 million US dollars, from the DAO into another account.
While the term "hacked" is often used, it is important to clarify that the smart contract functioned as intended; however, the inherent weaknesses in the smart contracts allowed the attacker to take advantage of the situation. This incident can be viewed as an unforeseen flaw (a bug) that the DAO developers did not anticipate.
Consequently, this event prompted a hard fork in the Ethereum blockchain to facilitate recovery from the attack. The DAO attack capitalized on a flaw in the DAO code, enabling the attacker to withdraw tokens from the DAO smart contract multiple times before the contract had the opportunity to update its internal state to reflect the number of tokens withdrawn. The attacker managed to execute several withdrawals, but ultimately, only one withdrawal was recorded by the smart contract, which also lost track of any subsequent withdrawals.
Security Issues of Decentralized Autonomous Organization (DAO)
The security issues of DAO are mentioned in the following bullet points below −
* The DAO attack highlights the dangers of not formally and thoroughly testing smart contracts.
* It also highlights the absolute need to develop a formal language for the development and verification of smart contracts.
* The attack also highlighted the importance of thorough testing to avoid the issues that the DAO experienced. There have been various vulnerabilities discovered in Ethereum over the last few years regarding the smart contract development language.
* It is of utmost importance that a standard framework is developed to address all these issues.
Some work has already begun, for example, an online service provider Securify, which provides tools to formally verify smart contract code.
Bitcoin, the pioneer of blockchain technology, started a revolution by introducing the first fully decentralized digital currency. While it has proven to be secure and valuable, Bitcoin is known for its instability and high volatility.
Since its inception in 2008 by Satoshi Nakamoto, Bitcoin has gained widespread popularity and is currently the leading digital currency globally, attracting billions of dollars in investments.
Drawing on extensive research in cryptography, digital cash, and distributed computing, Bitcoin's development is rooted in decades of innovation. The following section offers a concise history of the foundational principles in the creation of Bitcoin.
History of Bitcoin
Bitcoin was first introduced in 2008 through a paper titled Bitcoin: A Peer-to-Peer Electronic Cash System, authored by Satoshi Nakamoto. The true identity of Nakamoto remains unknown, leading to much speculation as to who the real inventor of Bitcoin is.
Bitcoin's foundation is rooted in extensive research spanning decades. It incorporates various cryptographic and distributed computing techniques, such as Merkle trees, hash functions, and digital signatures. Additionally, concepts from previous works like BitGold, b-money, hashcash, and cryptographic time stamping laid the groundwork for Bitcoin's creation. By ingeniously combining ideas from these sources, Bitcoin became the world's first decentralized digital currency.
Bitcoin addresses several long-standing challenges in electronic cash and distributed systems, including the following problems −
* Byzantine general’s problem
* Double-spending problem
* Sybil attacks
Bitcoin offers an elegant solution to these issues, making it a groundbreaking innovation in the realm of decentralized currencies.
What is Bitcoin?
Bitcoin is a very complex entity, which includes a protocol, a digital currency, and a platform. It operates through a combination of a peer-to-peer network, protocols, and software that enables the generation and utilization of the digital currency. Within this peer-to-peer network, nodes communicate with each other utilizing the Bitcoin protocol.
Bitcoin comprises the following components −
* Wallets (client software)
* Digital keys
* Addresses
* Transactions
* Miners
* The Bitcoin network
These terms and areas are discussed in further sections of this chapter. Some of the broader concepts are beyond the contents of this tutorial, and the users can cover the basic concepts of Bitcoin via this chapter.
Bitcoin Wallet
We can use the Bitcoin Wallet to engage in real-life transactions in Bitcoin values. There are many terms that users might come across while conducting transactions in the Bitcoin Wallet, which are explained as follows −
* Dimensions − This refers to the dimensions of the transaction in bytes.
* Mass − This is the updated measurement provided for the block and transaction sizes following the implementation of the segregated witness (SegWit) soft fork version of Bitcoin.
* Time of Receipt − This indicates the time at which the transaction was received.
* Inclusion in Blocks − This displays the block number on the blockchain where the transaction has been included.
* Verifications − This denotes the number of confirmations completed by miners for this transaction.
* Overall Inputs − This represents the total number of inputs in the transaction.
* Overall Outputs − This signifies the total number of outputs from the transaction.
* Charges − This is the complete fee applied.
* Fee per Byte − This value shows the total fee divided by the number of bytes in the transaction; for instance, 10 Satoshis per byte.
* Fee per Mass Unit − For traditional transactions, this is computed using the total number of bytes * 4.
In the case of SegWit transactions, it is calculated by merging a SegWit marker, flag, and witness field as one mass unit, and each byte of the other fields as four mass units.
What are Crypto-Keys?
On the Bitcoin network, the possession and transfer of Bitcoins rely on private keys, public keys, and addresses. Elliptic Curve Cryptography (ECC) is utilized to create public and private key pairs within the Bitcoin network.
Here is a brief explanation −
Private Keys
Private keys must be securely stored and typically remain solely with the owner. They are utilized to digitally sign transactions, demonstrating ownership of the bitcoins. Private keys are essentially 256-bit numbers randomly selected within the range specified by the SECP256K1 ECDSA curve recommendation.
For example, the consider the following private key −
A3ED7EC8A03667180D01FB4251A546C2B9F2FE33507C68B7D9D4E1FA5714195201


When converted into WIF format, it looks as shown here −
L2iN7umV7kbr6LuCmgM27rBnptGbDVc8g4ZBm6EbgTPQXnj1RCZP


Public Keys
Public keys are stored on the blockchain for all network participants to view. These public keys are generated from private keys through a unique mathematical relationship.
When a transaction is signed with a private key and shared on the Bitcoin network, nodes utilize public keys to confirm that the transaction was indeed signed with the corresponding private key. This verification process establishes ownership of the bitcoin. Bitcoin employs ECC based on the SECP256K1 standard, utilizing an Elliptic Curve Digital Signature Algorithm (ECDSA) to safeguard funds and restrict spending to the rightful owner.
Addresses in Bitcoin
A Bitcoin address is generated by applying a two-step hashing process to the corresponding public key of a private key. First, the SHA256 algorithm is used, followed by the RIPEMD160 algorithm. The resulting 160-bit hash is then combined with a version number and encoded using the Base58Check encoding scheme.
Bitcoin addresses typically consist of 26-35 characters and start with the digits 1 or 3. An example of a typical Bitcoin address is −
1ANAguGG8bikEv2fYsTBnRUmx7QUcK58w


Currently, there are two types of addresses: P2PKH, which starts with the number 1, and P2SH, which starts with the number 3.
Bitcoin addresses are often encoded in QR codes for easy distribution.
Bitcoins are a form of cryptocurrency that is used worldwide for decentralized transactions. But how does a bitcoin transaction work?
As we had discussed in earlier chapters, bitcoins have addressing present in them. These addresses are used for transactions, along with keys and the help of some professionals who solve bitcoin riddles. These professionals are known as Bitcoin Miners.
Let us dwell more into the seemingly difficult but actually fairly easy mode of bitcoin transactions.
Bitcoin Transaction Lifecycle
Let's examine the life cycle of a Bitcoin transaction. The process unfolds as follows −
* A user/sender initiates a transaction using wallet software or another interface.
* The wallet software digitally signs the transaction with the sender's private key.
* The transaction is disseminated across the Bitcoin network via a flooding algorithm.
* Mining nodes (miners) monitoring for transactions validate and add the transaction to the upcoming block to be mined. Prior to inclusion in the block, transactions are stored in a dedicated memory pool known as the transaction pool.
* Mining starts, which is a process that fortifies the blockchain and yields new coins as a reward for miners who allocate sufficient computational resources. Upon solving the PoW (Proof of Work) puzzle, a miner broadcasts the freshly mined block to the network.
* Ultimately, confirmations begin to surface in the recipient's wallet, and after roughly three confirmations, the transaction is deemed finalized and verified.
Who are Miners?
Miners are the actual brains behind the whole process of mining and solvin the puzzles in POW.
Upon establishing a connection to the Bitcoin network, a Bitcoin miner undertakes several essential responsibilities −
Network Synchronization
When a new node integrates into the Bitcoin network, it initiates the process of downloading the blockchain by requesting historical blocks from existing nodes
Validation of Transactions
Transactions disseminated across the network undergo validation by full nodes, which verify and authenticate signatures and outputs.
Validation of Blocks
Both miners and full nodes engage in the validation of blocks they receive by assessing them against specific criteria. This process includes verifying each transaction within the block as well as confirming the nonce value.
Creation of New Blocks
Miners generate a new block by aggregating transactions that have been broadcast on the network, following their validation.
Execution of Proof of Work (PoW)
This task constitutes the fundamental aspect of the mining process. The block header features a 32-bit nonce field, and miners must continuously adjust the nonce until the resulting hash meets a predetermined target.
Reward Acquisition
After a node successfully solves the hash puzzle (PoW), it promptly broadcasts the outcome, allowing other nodes to verify and accept the block.
Mining Pools
A mining pool is created when a collective of miners collaborate to mine a block. The pool administrator obtains the coinbase transaction upon successful mining of the block, and is tasked with distributing the reward among the miners who contributed resources to mine the block.
This method proves to be better than solo mining, where a single miner attempts to solve the partial hash inversion function (hash puzzle) alone, as in mining pools, the reward is distributed to every member of the pool irrespective of whether they (or their individual node) solved the puzzle or not.


The Bitcoin network operates as a peer-to-peer (P2P) system where nodes engage in transaction activities. These nodes are responsible for verifying and disseminating transactions and blocks. Among them, miners are specialized nodes that create new blocks. The network comprises various types of nodes, with the two primary categories being full nodes and simple payment verification (SPV) nodes.
Full nodes, which utilize Bitcoin Core client software, handle wallet functions, mining, complete blockchain storage, and network routing. However, not every node in the Bitcoin network is required to execute all these roles. SPV nodes, or lightweight clients, focus solely on wallet operations and network routing.
Identify a Bitcoin Network
The Bitcoin network is distinguished by its unique magic value, which serves to signify the originating network of a message. The subsequent table presents a compilation of these values −
A full Bitcoin node performs four functions. These are wallet, miner, blockchain and network routing. We have already discussed mining and blockchains in the previous chapters. Here, we continue where we left off, with the bitcoin network.
Protocol Messages in Bitcoin Network
There are currently some distinct types of protocol messages, with the potential for this number to grow as the protocol evolves. Below is a list of the most frequently utilized protocol messages along with their descriptions −
* Version − This initial message is sent by a node to the network, indicating its version and block count. The remote node responds with the same details, establishing the connection.
* Verack − This message acknowledges the version message and accepts the connection request.
* Inv − Nodes use this message to announce their awareness of blocks and transactions.
* Getdata − This message is a response to an inv, requesting a specific block or transaction identified by its hash.
* Getblocks − This returns an inv packet that includes a list of all blocks starting from the last known hash or up to 500 blocks.
* Getheaders − This message requests block headers within a specified range.
* Tx − This is used to transmit a transaction in response to the getdata protocol message.
* Block − This message sends a block in reply to the getdata protocol message.
* Headers − This packet can return up to 2,000 block headers as a response to the getheaders request.
* Getaddr − This message is sent to request information about known peers.
* Addr − This provides details about nodes on the network, including the number of addresses and a list of addresses formatted as IP address and port number.
* Ping − This message is utilized to verify the activity of the TCP/IP network connection.
* Pong − This message serves as a response to a ping, confirming that the network connection is operational.
What Happens in a Bitcoin Network?
The process of transmission of message via protocols is performed in a bitcoin network. This occurs in a chronological order, which is given below −
* In the bitcoin network, the process starts when the client transmits a protocol message known as a version message, which includes several fields such as version, services, timestamp, network address, nonce, and additional information.
* In response, the remote node sends its own version message, followed by an exchange of verack messages between both nodes, confirming that the connection has been successfully established.
* Subsequently, getaddr and addr messages are exchanged to identify peers that the client is not already aware of.
* During this process, either node may send a ping message to verify the ongoing status of the connection. The getaddr and addr message types are specified within the Bitcoin protocol.
This network protocol sequence diagram illustrates the communication between two Bitcoin nodes during the initial connection phase.
In the given example, Node A is positioned on the left, while Node B is on the right. Node A initiates the connection by sending a version message that includes the version number and the current timestamp to the remote peer, Node B. Node B then replies with its own version message, which also contains the version number and current time.
Following this, Node A and Node B exchange verack messages, signifying that the connection has been successfully established. Once the connection is confirmed, the peers can exchange getaddr and addr messages to discover additional peers within the network.
At this point, the process of downloading blocks can commence. If the node has already synchronized all blocks, it will listen for new blocks using the inv protocol message. If not, it first checks for responses to inv messages and whether it possesses inventories. If inventories are available, it will request the blocks using the getdata protocol message; if not, it will request inventories through the getblocks message.
Full Client and SPV Client
The Bitcoin network nodes can function in two primary modes: as full clients or as lightweight SPV clients. Full clients, also known as thick clients or full nodes, download the entire blockchain, providing the highest level of security for validating transactions.
In contrast, SPV clients allow users to verify payments without the need to download the complete blockchain. These SPV nodes maintain only the block headers of the longest valid blockchain. Verification is achieved by examining the Merkle branch, which connects transactions to the original block in which they were recorded. This method can be somewhat impractical, necessitating a more efficient solution, which was introduced through BIP37.
Bloom Filters
A bloom filter is a specialized data structure, specifically a bit vector with indexed positions, designed to probabilistically assess the membership of an element. It allows for probabilistic lookups that may yield false positives but guarantees no false negatives. This implies that while the filter may incorrectly indicate that an element is part of the tested set, it will never falsely claim that an existing element is absent. In essence, false positives can occur, but false negatives are impossible.
To incorporate elements into the bloom filter, they are hashed multiple times, and the corresponding bits in the bit vector are set to 1 based on the resulting indices. To verify the presence of an element, the same hash functions are applied, and the bits in the bit vector are checked to see if they are all set to 1.
Bloom filters are primarily utilized by simple payment verification (SPV) clients to request specific transactions and the associated Merkle blocks.
A Merkle block serves as a compact representation of a block, containing a block header, several hashes, a list of 1-bit flags, and a transaction count. This data can be utilized to construct a Merkle tree. The filter is tailored to match only those transactions and blocks that the SPV client has requested. After exchanging version messages and establishing a connection between peers, nodes can configure filters based on their specific needs.


The Bitcoin Wallet software is designed to create and manage cryptographic keys. It offers several essential functions, including the ability to send and receive Bitcoin, back up keys, and monitor the available balance.
Typically, Bitcoin client software encompasses both the client and wallet functionalities. The wallets associated with the Bitcoin Core client are saved on disk as Berkeley DB files.
Private keys are produced by randomly selecting a 256-bit number generated by the wallet software. These private keys enable wallets to authorize outgoing transactions. It is important to note that wallets do not actually hold any coins; rather, they do not maintain a balance or store coins for users. In the Bitcoin network, coins are not physically present; instead, only transaction data is recorded on the blockchain, specifically in the form of unspent transaction outputs (UTXOs), which are utilized to determine the total amount of bitcoins.
Within the Bitcoin ecosystem, various types of wallets are available for storing private keys. As software solutions, they also offer users functionalities to manage and execute transactions on the Bitcoin network.
Types of Bitcoin Wallets
Let us explore the common types of wallets, which are given in the further sections −
Non-deterministic Wallets
Non-deterministic wallets are characterized by their use of randomly generated private keys, often referred to as Just a Bunch of Keys wallets.
When the Bitcoin Core client is initially launched, it generates a set of keys and continues to create additional keys as needed. Handling a significant number of keys can be challenging and prone to errors, which may result in the theft or loss of cryptocurrency.
Additionally, it is essential to regularly back up these keys and ensure their security, such as through encryption, to mitigate the risks of theft or loss.
Deterministic Wallets
Deterministic wallets utilize a seed value to derive keys through hash functions. This seed is generated randomly and is often expressed using human-readable mnemonic phrases. These mnemonic phrases are outlined in BIP39, a Bitcoin improvement proposal that facilitates the generation of deterministic keys.
By using these phrases, users can recover all associated keys, simplifying the management of private keys.
Hierarchical Deterministic Wallets
Hierarchical deterministic wallets, as outlined in BIP32 and BIP44, utilize a tree structure to store keys, all derived from a single seed. This seed creates the master key, which in turn generates child keys and further extends to grandchild keys. Rather than producing keys directly, HD wallets generate private key generation information that facilitates the creation of a series of private keys.
The entire hierarchy of private keys can be easily restored if the master private key is accessible. This characteristic makes HD wallets user-friendly and highly portable. Numerous HD wallets are available, both free and commercial, including options like Trezor, Jaxx, and Electrum.
Paper Wallets
As the name implies, this is a paper-based wallet with the required key material printed on it. It requires physical security to be stored.
Brain Wallets
Brain wallets utilize a master private key that can be generated from the hashes of memorized passwords. The fundamental concept is that this passphrase serves as the basis for deriving the private key.
When applied in hierarchical deterministic (HD) wallets, it can create a complete HD wallet from just one remembered password. This approach is referred to as a brain wallet.
Hardware Wallets
Hardware wallets represent an alternative approach for securely storing keys through the use of tamper-resistant devices. These devices can be specifically designed for this purpose.
Additionally, with the rise of NFC-enabled smartphones, a secure element (SE) can be integrated into these devices. Among the various options available, Trezor and Ledger wallets are the most widely utilized hardware wallets for Bitcoin.
Online Wallets
Online wallets, as suggested by their name, are completely hosted on the internet and are typically offered as a cloud-based service. They allow users to access a web interface for managing their wallets and executing a range of functions, including sending and receiving payments.
While they are user-friendly, they require a level of trust in the service provider. A notable example of an online wallet is GreenAddress.
Mobile Wallets
Mobile wallets, as indicated by their name, are applications designed for mobile devices. They offer multiple payment options, particularly the convenience of using smartphone cameras to swiftly scan QR codes for transactions.
These wallets are compatible with both Android and iOS platforms and include options such as Blockchain Wallet, Breadwallet, Copay, and Jaxx.
How to Choose a Bitcoin Wallet?
The following points clearly explain how to choose a bitcoin wallet for payments and other transactions −
* The selection of a Bitcoin wallet is influenced by various factors, including security, user-friendliness, and the features offered.
* Among these considerations, security is the most critical aspect, and it should take precedence when choosing a wallet.
* Hardware wallets are generally regarded as more secure than web wallets due to their design, which is resistant to tampering.
* In contrast, web wallets are hosted online, which may expose them to greater security risks compared to a hardware device.
* Mobile wallets for smartphones have gained significant popularity, as they provide a favorable mix of features and security.
* Numerous companies offer these wallets on platforms like the iOS App Store and Google Play.
* However, recommending a specific type of wallet can be challenging, as it largely depends on individual preferences and the specific features each wallet provides.
* It is essential to prioritize security when making a decision about which wallet to utilize.
We have explored numerous concepts associated with Bitcoin payments and transactions, along with relevant techniques and ideas. Our discussion on Bitcoin payments concludes here, and we will now transition to the distinct yet significant topic of innovation.
The landscape of Bitcoin and blockchain technology is constantly evolving, and we will examine some of the most pertinent concepts in the upcoming sections.
Enhancements in Bitcoin Technology
Bitcoin has experienced numerous transformations and continues to develop into a more robust and efficient system, by tackling its inherent weaknesses. The topic of performance has sparked considerable discussion among Bitcoin experts and enthusiasts for many years. A variety of proposals have emerged in recent years aimed at enhancing Bitcoin's performance, leading to improvements in transaction speed, security, payment standardization, and overall protocol efficiency.
These enhancement proposals typically take the form of Bitcoin Improvement Proposals (BIPs) or entirely new iterations of Bitcoin protocols, which can result in the creation of new networks. Some proposed changes can be executed through a soft fork, while others necessitate a hard fork, ultimately resulting in the emergence of a new currency.
In the subsequent sections, we will examine the different BIPs that have been suggested for Bitcoin's enhancement. We will also explore some advanced protocols that have been proposed and implemented to rectify various vulnerabilities within the Bitcoin framework.
What is Bitcoin Improvement Proposals (BIP)?
Bitcoin Improvement Proposals, commonly known as BIPs, serve as a means to suggest enhancements or to communicate updates to the Bitcoin community regarding proposed improvements, design challenges, or various elements of the Bitcoin ecosystem.
BIPs are categorized into three distinct types −
Standard Bitcoin Improvement Proposals
This type addresses significant modifications that substantially affect the Bitcoin system, including alterations to block size, changes in network protocols, or updates to transaction verification processes.
Process of Bitcoin Improvement Proposals
Unlike standard BIPs, which focus on protocol modifications, process BIPs are concerned with proposing changes to processes that exist outside the core Bitcoin protocol. Implementation of these proposals occurs only after achieving consensus among Bitcoin users.
Informational Bitcoin Improvement Proposals
These proposals primarily serve to provide guidance or document information related to the Bitcoin ecosystem, including design challenges and other relevant topics.
Segregated Witness in Bitcoin Technology
Segregated Witness, commonly referred to as SegWit, is an upgrade to the Bitcoin protocol implemented as a soft fork. This enhancement addresses several vulnerabilities related to throughput and security within the Bitcoin framework.
The key improvements offered by SegWit include −
* A solution to transaction malleability by separating signature data from transaction data. This separation ensures that the transaction ID cannot be altered, as it is no longer derived from the signature data included in the transaction.
* By isolating signature data from transaction data, lightweight clients can avoid downloading unnecessary signatures, allowing for transaction verification without the extraneous data and enhancing bandwidth efficiency.
* A decrease in the time required for transaction signing and verification, leading to quicker transactions. A new hashing algorithm for signature verification, detailed in BIP0143, has been introduced, resulting in linear growth of verification time relative to the number of inputs, rather than quadratic growth, thus expediting the process.
* The introduction of script versioning, which facilitates easier upgrades to the script language. By prefixing the version number to locking scripts, enhancements can be made without necessitating a hard fork, simply by updating the script version number.
* An increase in block capacity through the implementation of a weight limit rather than a size limit, along with the exclusion of signature data. This concept will be elaborated on further.
* A new address format known as the "bc1 address," which utilizes the Bech32 encoding method instead of base58. This upgrade enhances error detection and correction capabilities, features all lowercase characters for improved readability, and aids in differentiating between legacy and SegWit transactions.
Bitcoin Cash
Bitcoin Cash (BCH) expands the block size limit to 8 MB, significantly enhancing the number of transactions that can be accommodated within a single block, in contrast to the original Bitcoin protocol's 1 MB limit. It employs a Proof of Work (PoW) consensus mechanism, utilizing ASIC-based mining hardware.
The block generation time is adjusted from 10 minutes to a range of 10 seconds to 2 hours. Additionally, BCH incorporates replay protection and wipe-out protection, ensuring that its distinct hashing algorithm prevents transactions from being replayed on the Bitcoin blockchain. Furthermore, it utilizes a different signature type than Bitcoin, allowing for clear differentiation between the two blockchains.
Bitcoin Unlimited
Bitcoin Unlimited is designed to enhance the block size without imposing a strict limit. Instead, it relies on miners reaching a consensus regarding the block size cap over time. Additionally, Bitcoin Unlimited has introduced concepts such as extremely thin blocks and parallel validation. These concepts are explained in the next section −
Extremely Thin Blocks
Extremely thin blocks facilitate quicker block propagation among Bitcoin nodes. In this approach, the node that requests blocks sends a getdata request accompanied by a bloom filter to another node. The bloom filter serves to exclude transactions that are already present in the requesting node's memory pool (mempool).
Parallel Validation
Parallel Validation enables nodes to validate multiple blocks and new incoming transactions simultaneously. This approach contrasts with Bitcoin's current method, where a node cannot relay new transactions or validate additional blocks during its validation period after receiving a new block until it has either accepted or rejected that block.
Bitcoin Gold
This initiative was executed as a hard fork starting from block 491407 of the original Bitcoin blockchain. As a result of this hard fork, a new blockchain emerged, known as Bitcoin Gold.
The primary objective of this project is to tackle the problem of mining centralization, which has undermined the foundational principle of Bitcoin as decentralized digital currency, where an increase in hash power has led to a concentration of power among miners with greater hashing capabilities.
Bitcoin Gold employs the Equihash algorithm for mining, distinguishing itself from the traditional Proof of Work (PoW) method; thus, it is designed to be ASIC resistant and utilizes GPUs for the mining process.
Ethereum, similar to other blockchains, can be conceptualized as a state machine that operates on transactions. This concept is outlined in the Ethereum yellow paper authored by Dr. Gavin Wood.
The fundamental principle is that the Ethereum blockchain evolves from an initial state to a conclusive state through the incremental execution of transactions. The resulting final state is recognized as the definitive and unquestionable version of the blockchain's state.
Ethereum - How It Emerged?
In November 2013, Vitalik Buterin introduced the concept of Ethereum. The primary vision was to create a Turing-complete programming language that would enable the development of diverse applications, known as smart contracts, for blockchain and Decentralized Applications (DApps). This approach stands in stark contrast to Bitcoin, which features a more restricted scripting language that only supports essential functions.
The initial version of Ethereum, named Olympic, launched in May 2015, followed by the Frontier version in July of the same year. In March 2016, the Homestead version was released, incorporating several enhancements. The most recent update, Muir Glacier, was designed to postpone the difficulty bomb.
Ethereum Yellow Paper
The Ethereum Yellow Paper, authored by Dr. Gavin Wood, who is the founder of both Ethereum and Parity, provides a formal specification of the Ethereum protocol. This document allows anyone to create an Ethereum client by adhering to the outlined protocol specifications.
Although the paper may be difficult to comprehend for individuals lacking a background in algebra or mathematics, as well as those unfamiliar with mathematical notation, it offers a comprehensive formal specification of Ethereum.
The Ethereum Network
The Ethereum network operates as a decentralized peer-to-peer system where nodes collaborate to uphold the blockchain and facilitate the consensus process.
This network can be categorized into three distinct types based on their specific requirements and applications, which are detailed in the following sections −
The Mainnet
The mainnet represents the active, operational network of Ethereum, identified by a network ID of 1 and a chain ID of 1. These identifiers are essential for recognizing the network.
Testnets
Ethereum offers several testnets designed for testing purposes. These test blockchains serve as environments for evaluating smart contracts and decentralized applications (DApps) prior to their deployment on the live production blockchain.
Additionally, these test networks support experimentation and research initiatives. The primary testnet is known as Ropsten, which encompasses all functionalities of other smaller, specialized testnets created for particular releases.
Private Nets
As indicated by the name, private nets are exclusive networks established by generating a new genesis block. This scenario typically occurs in private blockchain networks, where a select group of entities initiates their own blockchain network, utilizing it as a permissioned or consortium blockchain.
The Ecosystem of the Ethereum blockchain comprises several integral components. At its foundation lies the Ethereum blockchain, which operates on a decentralized peer-to-peer network.
Additionally, there exists an Ethereum client, typically Geth, that functions on the nodes and establishes a connection to the peer-to-peer Ethereum network, facilitating the download and local storage of the blockchain.
This client offers a range of functionalities, including mining and account management. The local blockchain copy is consistently synchronized with the network. Another essential element is the web3.js library, which enables interaction with the Geth client through the Remote Procedure Call (RPC) interface.
Components of Ethereum Ecosystem
The components of Ethereum Ecosystem are given as follows −
* Keys and Addresses
* Accounts
* Transactions
* Messages
* Ether Cryptocurrency/Tokens
* The EVM
This chapter will cover the former topics, whereas the next chapter focuses on the EVM (Ethereum Virtual Machine) in detail.
Keys and Addresses
In the Ethereum blockchain, keys and addresses serve the purpose of denoting ownership and facilitating the transfer of ether. These keys consist of pairs, comprising a private key and a public key.
The private key is generated randomly and remains confidential, while the public key is derived from the private key. Addresses, which are 20-byte codes, are generated from public keys and are utilized to identify accounts.
How to Generate Keys and Addresses?
The procedure for generating keys and deriving addresses is outlined as follows −
* Initially, a private key is randomly selected (a 256-bit positive integer) in accordance with the specifications of the elliptic curve secp256k1.
* Then, the public key is derived from the private key through the use of the Elliptic Curve Digital Signature Algorithm (ECDSA) recovery function.
* Finally, an address is generated from the public key, specifically from the last 160 bits of the Keccak hash of the public key.
Accounts of Ethereum Ecosystem
Accounts serve as fundamental components of the Ethereum blockchain. They consist of pairs of private and public keys. Users utilize accounts to engage with the blockchain through transactions.
Prior to submitting a transaction to the network via a node, it is digitally signed by the respective account. As a transaction-driven state machine, Ethereum's state is established or modified through the interactions between accounts and the execution of transactions.
State Transition of Ethereum Ecosystem
Each account within the Ethereum network possesses a state that, when aggregated, reflects the overall condition of the network. The state of the Ethereum network is refreshed with each new block added.
The actions executed between and on these accounts signify state transitions. This transition is facilitated by the Ethereum state transition function, which operates as follows −
* The validity of the transaction is confirmed through checks on syntax, signature authenticity, and nonce.
* The transaction fee is determined, and the sender's address is identified via the signature.
* Additionally, the sender's account balance is verified and adjusted accordingly, with the nonce being incremented.
* Sufficient ETH must be provided to cover the transaction costs, which are calculated per byte and increase proportionally with the transaction size. This step involves the actual transfer of value, moving from the sender's account to the recipient's account.
* If the specified destination account does not yet exist, it is created automatically.
* In instances where a transaction fails due to insufficient balance or gas, all state modifications are reverted, except for the fee payment, which is allocated to the miners.
* Ultimately, any remaining fee is returned to the sender as change, and the fee is distributed to the miners accordingly.
* At this stage, the function yields the resulting state, which is also recorded on the blockchain.
Types of Accounts
There are two categories of accounts within the Ethereum Ecosystem −
* Externally Owned Accounts (EOAs)
* Contract Accounts (CAs)
Externally Owned Accounts function similarly to Bitcoin accounts, being governed by a private key. In contrast, Contract Accounts are distinguished by their association with executable code in addition to a private key.
The key features and properties of both types of accounts are given in the following section −
EOAs
The key features of Externally Owned Accounts are given as follows −
* They possess a state.
* They are linked to a human user, which is why they are referred to as user accounts.
* EOAs maintain an ether balance.
* They have the ability to send transactions.
* They do not contain any associated code.
* Control is exercised through private keys.
* EOAs are unable to initiate a call message.
* Accounts feature a key-value store.
* EOAs are capable of initiating transaction messages.
CAs
The key features of Contract Accounts are given as follows −
* They possess a state.
* They are not inherently linked to any user or entity on the blockchain.
* CAs maintain an ether balance.
* They include associated code that is stored in memory or on the blockchain. They have access to storage.
* They can be triggered to execute code in response to transactions or messages from other contracts.
* CAs can preserve their permanent states and can invoke other contracts.
* CAs are unable to initiate transaction messages.
* CAs can initiate a call message.
* CAs feature a key-value store.
* The addresses of CAs are generated upon deployment, and this address is utilized to identify their location on the blockchain.
Transactions of Ethereum Ecosystem
In the Ethereum Ecosystem, a transaction is defined as a data packet that is digitally signed with a private key, containing specific instructions that, upon execution, lead to either a message call or the establishment of a contract.
Transactions can be categorized into two distinct types based on their outcomes −
Message call transactions
These transactions facilitate the transmission of messages between different contract accounts (CAs) without creating new accounts.
Contract Creation Transactions
These transactions result in the formation of a new contract account. Successful execution of such a transaction leads to the creation of an account that is associated with particular code.
Key Terms in Transactions
Both transactions consist of several standard fields, which are detailed as follows −
Nonce
The nonce is a sequential number that increases by one with each transaction initiated by the sender. It must correspond to the total number of transactions sent and serves as a unique identifier for the transaction.
Gas Price
The gas price field indicates the amount of Wei necessary to carry out the transaction. This fee is applied per unit of gas for all computational expenses incurred during the transaction's execution.
Gas limit
The gas limit field specifies the maximum amount of gas that may be utilized to execute the transaction.
To
The To field denotes the address of the transaction's recipient, represented as a 20-byte value.
Value
The Value field indicates the total amount of Wei to be transferred to the recipient. In the context of a contract account (CA), this reflects the balance that the contract will maintain.
Signature
The signature comprises three components: V, R, and S. These values represent the digital signature (R, S) and additional information that aids in recovering the public key (V).
Init
The Init field is exclusively utilized in transactions aimed at creating contracts, specifically contract creation transactions. It represents a byte array of unlimited length that defines the EVM code to be employed in the account initialization process.
Data
In the case of a message call transaction, the Data field replaces Init and contains the input data for the message call. This field is also of unlimited size and is structured as a byte array.
Messages of Ethereum Ecosystem
According to the yellow paper, Messages refer to the data and values exchanged between two accounts. A message is essentially a data packet that carries both information and a value, specifically the amount of ether involved. These messages can be transmitted through a smart contract, which acts as an autonomous entity, or initiated by an external actor, known as an Externally Owned Account (EOA), through a digitally signed transaction.
Contracts have the capability to send messages to other contracts. It is important to note that messages exist solely within the execution environment and are not stored. While messages share similarities with transactions, the key distinction lies in their origin: messages are generated by contracts, whereas transactions originate from external entities within the Ethereum ecosystem (EOAs).
Components of a Message
A message is composed of several key elements −
* The individual or entity sending the message
* The individual or entity receiving the message
* The quantity of Wei to be transferred along with the message directed to the contract address
* An optional data field, which serves as input for the contract
* The maximum gas limit (startgas) that may be utilized
Messages are created when the CALL or DELEGATECALL opcodes are executed by the contract operating within the EVM.
Ethereum Tokens (ETH/ETC)
Ethereum has its own native cryptocurrency known as ether (ETH). Following the Decentralized Autonomous Organization (DAO) hack discussed earlier in this tutorial, a hard fork was initiated to address the situation.
As a result, there are now two distinct Ethereum blockchains: one is referred to as Ethereum Classic, represented by the currency ETC, while the hard-forked version is ETH, which continues to evolve with ongoing development efforts.
Ethereum Classic (ETC) has cultivated its own community of supporters who are actively working on its development, maintaining it as the original, unforked version of Ethereum.
Ether is generated by miners as a reward for their computational work in securing the network through transaction and block verification. Within the Ethereum blockchain, ether serves as the medium for executing contracts on the Ethereum Virtual Machine (EVM).
Additionally, ether is utilized to purchase gas, which acts as the necessary fuel for conducting computations on the Ethereum blockchain. The following table gives the denomination of different units and their values −
The Ethereum Virtual Machine (EVM) operates as a straightforward stack-based execution environment that processes bytecode instructions to transition the system state from one condition to another.
While the EVM is Turing-complete, its operations are constrained by the gas required for executing instructions. This limitation prevents the occurrence of infinite loops that could lead to denial-of-service attacks. Additionally, the EVM is equipped with exception handling mechanisms to address potential issues, such as insufficient gas or invalid instructions, causing the machine to halt and return an error to the executing agent.
Ethereum Virtual Machine Structure
The Ethereum Virtual Machine (EVM) utilizes a 256-bit word size, and its stack can accommodate up to 1,024 elements, functioning on a Last In, First Out (LIFO) principle. It operates as a completely isolated and sandboxed runtime environment. Code executed within the EVM is restricted from accessing external resources, including networks or filesystems.
This design enhances security, ensures deterministic execution, and permits the execution of untrusted code—code that can be run by any user—on the Ethereum blockchain. As previously mentioned, the EVM utilizes a stack-based architecture. It is inherently big-endian and employs 256-bit-wide words, which facilitate Keccak 256-bit hashing and elliptic curve cryptography (ECC) computations.
Types of Storage
There are three primary types of storage utilized for contracts and the Ethereum Virtual Machine (EVM) −
Memory
The first type is referred to as memory or volatile memory, which functions as a word-addressed byte array. Once a contract completes its execution, the memory is reset. This is similar to RAM in traditional computing. Write operations can be performed in either 8 or 256 bits, while read operations are restricted to 256-bit words.
Storage
The second type is known as storage, which operates as a key-value store and is permanently recorded on the blockchain. Both keys and values are 256 bits in size. It can be compared to hard disk storage in conventional systems.
Stack
The EVM functions as a stack-based machine, executing all computations within a data area called the stack. All values held in memory are also stored in the stack. The stack has a maximum depth of 1024 elements and accommodates a word size of 256 bits.
Execution Environment
The execution environment necessitates several essential components to run the code effectively. These critical parameters are supplied by the execution agent, such as a transaction.
The following elements are required −
* The current system state.
* The available gas for execution.
* The address of the account that owns the code being executed.
* The address of the transaction sender, which serves as the origin for this execution and may differ from the sender's address.
* The gas price associated with the initiating transaction.
* Input data or transaction data, depending on the executing agent type. This is represented as a byte array.
* The address of the account that initiated the code execution or the transaction sender.
* The value or transaction value, expressed in Wei. If the execution agent is a transaction, this represents the transaction value.
* The code to be executed, provided as a byte array, which the iterator function retrieves during each execution cycle.
* The block header of the current block.
* The count of message calls or contract creation transactions (CALLs, CREATEs, or CREATE2s) that are currently being executed.
* Authorization to modify the state.
The Machine State
The internal maintenance of the machine state occurs, with updates made following each execution cycle of the EVM. An iterator function, which will be elaborated on in the subsequent section, operates within the EVM to produce the results from a single cycle of the state machine.
The machine state is represented as a tuple containing the following components −
* Available gas
* The program counter, a positive integer that can be as large as 256
* The memory contents, represented as a series of zeroes totaling 2256 in size
* The count of active words in memory, continuously tracked from position 0
* The contents of the stack.
Iterator Function
The Iterator function carries out several essential tasks that are crucial for determining the next state of both the machine and the overall world state. These tasks encompass the following −
* It retrieves the next instruction from a byte array that contains the machine code within the execution environment.
* It appropriately adds or removes items from the stack using PUSH or POP operations.
* Gas consumption is adjusted based on the gas costs associated with the instructions or opcodes, and the Program Counter (PC) is incremented accordingly.
Additionally, the EVM has the capability to halt under normal circumstances when it encounters the STOP, SUICIDE, or RETURN opcodes during its execution cycle.
Ethereum Blockchain has emerged as a very popular blockchain in the modern era. In this chapter, we will discuss some advanced Ethereum topics, like the Genesis Block, Block Difficulty, Gas and many more. Following this, the next chapters will discuss some important concepts of Ethereum Blockchain like Ethereum Wallets and the Role of Ethereum Miners.
Blocks and Blockchain in Ethereum
Blocks serve as the fundamental structural components of a blockchain. In Ethereum, each block is composed of several key elements, which include −
1. List of Transactions
The block contains a comprehensive list of all transactions that have taken place, as well as a list of the headers for any uncle blocks associated with it.
2. Headers of Ommers or Uncles
An uncle block refers to a block that is a descendant of a parent block but lacks any child blocks of its own. Ommers, or uncle blocks, are considered valid yet stale blocks that do not belong to the primary chain, although they enhance the overall security of the blockchain.
3. Block Header
Block headers represent the essential and intricate elements of an Ethereum block. Each header comprises several components, which are elaborated as follows −
* Parent hash − This refers to the Keccak 256-bit hash of the header from the preceding block.
* Ommers hash − This is the Keccak 256-bit hash representing the list of ommers (or uncle blocks) that are included in the current block.
* Beneficiary − This field holds the 160-bit address of the entity designated to receive the mining reward upon the successful mining of the block.
* State root − The state root field contains the Keccak 256-bit hash of the root node within the state trie.
* Transactions root − This is the Keccak 256-bit hash of the root node of the transaction trie.
* Receipts root − The receipts root is the Keccak 256-bit hash of the root node of the transaction receipt trie, which includes the receipts for all transactions within the block.
* Logs bloom − The logs bloom is a bloom filter that aggregates the logger addresses and log topics from the log entries of each transaction receipt in the block's transaction list.
* Difficulty − This indicates the difficulty level associated with the current block.
* Number − This represents the cumulative count of all preceding blocks, with the genesis block designated as block zero.
* Gas limit − This field indicates the maximum allowable gas consumption for the block.
* Gas used − This field reflects the total gas expended by the transactions contained within the block.
* Timestamp − The timestamp denotes the epoch Unix time at which the block was initialized.
* Extra data − The extra data field is available for storing any arbitrary information pertinent to the block.
* Mixhash − The mixhash field contains a 256-bit hash utilized to demonstrate that sufficient computational effort (Proof of Work, or PoW) has been exerted to create the block.
* Nonce − The nonce is a 64-bit hash (a numerical value) that, in conjunction with the mixhash field, serves to validate that adequate computational effort (PoW) has been applied.
The Genesis Block
The genesis block represents the initial block within a blockchain network. It differs somewhat from standard blocks in terms of its content and the method of its creation. This block includes 15 specific items like timestamp, nonce, hash and many more.
Block Validation
An Ethereum block is deemed valid if it meets the following criteria −
* It aligns with the uncles and transactions, ensuring that all ommers are recognized as uncles and that the Proof of Work (PoW) for these uncles is legitimate.
* The preceding block must exist and be valid.
* The block's timestamp must be valid, meaning it should be later than the timestamp of the parent block and not exceed 15 minutes into the future.
* If any of these conditions are not met, the block will be rejected.
Block Finalization
Block finalization is a critical process conducted by miners to authenticate the contents of a block and distribute rewards. This process encompasses four distinct steps, which are elaborated as follows −
Ommers Validation
In mining, the identification of ommers is essential. This involves validating the headers of stale blocks to ensure their legitimacy and confirming that the relationship between the uncle and the current block adheres to a maximum depth of six blocks.
Transaction Validation
In mining, the identification of transactions is crucial. This step entails verifying that the total gas utilized in the block corresponds to the final gas consumption after the last transaction, essentially reflecting the cumulative gas expended by the transactions within the block.
Reward Application
This step involves the distribution of rewards, which entails updating the beneficiary's account with the corresponding reward balance. In Ethereum, miners also receive compensation for stale blocks, amounting to 1/32 of the block reward.
State and nonce Validation
This final step requires the verification of the state and block nonce. In the context of mining, it is necessary to compute a valid state and block nonce.
Gas
Every operation executed on the Ethereum blockchain necessitates the payment of gas. This mechanism is crucial in preventing infinite loops from causing the entire blockchain to freeze, given the Turing-complete characteristics of the Ethereum Virtual Machine (EVM). A transaction fee, expressed in Ether, is deducted from the balance of the account initiating the transaction.
Miners require a fee to include transactions in their mining efforts. If this fee is set too low, the transaction may not be processed; conversely, a higher fee increases the likelihood of miners selecting the transaction for inclusion in a block. However, if a transaction with an adequate fee is included but involves excessively complex operations, it may trigger an out-of-gas exception if the allocated gas is insufficient. In such instances, the transaction will fail but will still be recorded in the block, and the originator will not receive a refund.
Transaction costs can be calculated using the following formula −
Total cost = gasUsed * gasPrice


Fee Schedule
Gas is incurred in three specific situations as a requirement for carrying out an operation −
* When calculating an operation
* During the creation of contracts or when making message calls
* When there is an increase in memory usage
Ethereum is currently experiencing significant development and transformation, leading to the creation and introduction of numerous components, clients, and tools in recent years.
A wallet serves as a versatile application that securely stores private keys. By utilizing the addresses contained within, it can determine the ether balance linked to those addresses through blockchain queries. Additionally, it facilitates the deployment of smart contracts.
Popular Wallets and Client Software
After examining the function of wallets in the Ethereum ecosystem, we will now explore several widely used clients.
Below is a partial list of the client software and wallets that are compatible with Ethereum −
* Geth − This is the official Ethereum client developed in Go.
* Eth − This client is implemented in C++.
* Parity − Developed by Parity Technologies, this client is built using Rust.
* Trinity − Trinity serves as the implementation of the Ethereum protocol and is written in Python.
Light Clients
Simple Payment Verification (SPV) clients only download a limited portion of the blockchain. This capability enables low-resource devices, including mobile phones, embedded systems, and tablets, to verify transactions effectively.
In this scenario, a full Ethereum blockchain and node are unnecessary, yet SPV clients can still confirm the validity of transactions. SPV clients are often referred to as light clients, a concept that parallels Bitcoin SPV clients.
Metamask Wallet
There are several wallets designed for Ethereum that cater to desktop, mobile, and web platforms. One widely used wallet is MetaMask, which is favored for Ethereum development.
MetaMask functions as a browser extension and is compatible with Chrome, Firefox, Opera, and Brave. The primary purpose of MetaMask's development is to create a user-friendly interface for interacting with the Ethereum blockchain. It facilitates effective account management and enables users to connect to the Ethereum blockchain without the need to run Ethereum node software on their local machines.
By utilizing the infrastructure provided by Infura, MetaMask allows users to engage with the blockchain seamlessly without the requirement of hosting a local node.
Clients Vs. Wallets
The primary distinction between clients and wallets lies in their functionalities. Clients serve as comprehensive implementations of the Ethereum protocol, encompassing mining capabilities, account management, and wallet features.
On the other hand, wallets are limited to storing public and private keys, facilitating basic account management, and primarily engaging with the blockchain for payment transactions.


The ethereum network comprises various types of nodes. Some function solely as wallets, while others serve as light clients, and a select few operate as full clients that maintain the entire blockchain.
Among these, mining nodes are particularly significant. Mining refers to the method through which new blocks are chosen through a consensus mechanism and subsequently added to the blockchain.
Through the mining process, miners receive currency (ether) as a reward for their efforts. These mining nodes, referred to as miners, are compensated in ether to encourage them to validate and authenticate blocks that consist of transactions. This mining activity plays a crucial role in securing the network by ensuring the accuracy of computations.
Functions of Miner Node
A miner node carries out several key functions −
* It monitors the transactions that are broadcast across the Ethereum network and selects which transactions to process.
* It identifies stale ommer blocks and incorporates them into the blockchain.
* It updates the account balance to reflect the rewards obtained from successfully mining a block.
* Ultimately, a valid state is calculated, and the block is finalized, representing the outcome of all state transitions.
The current mining approach utilizes Proof of Work (PoW), akin to that of Bitcoin. For a block to be considered valid, it must meet not only the general consistency criteria but also include the PoW corresponding to a specified difficulty level.
Casper of Ethereum
A new algorithm called Casper has been created to supplant the current Proof of Work (PoW) algorithm in Ethereum. This system operates on an economic protocol that mandates nodes to provide a security deposit prior to their ability to generate blocks.
In this context, nodes are referred to as bonded validators, and the process of providing the security deposit is termed bonding.
Consensus Mechanism of Ethereum
Ethereum implements a streamlined version of this protocol, designating the chain with the highest computational investment as the definitive version.
Alternatively, one can identify the longest chain, as it reflects the substantial mining efforts expended.
The GHOST protocol was initially proposed to address challenges associated with rapid block generation, which often resulted in stale or orphaned blocks. In the GHOST framework, stale blocks, referred to as ommers, are incorporated into the calculations to determine the longest and heaviest chain of blocks.
As the blockchain evolves with the addition of new blocks, governed by the consensus mechanism, it may occasionally experience a split, a phenomenon known as forking.
Forks of Ethereum
A fork in a blockchain refers to the division of the chain into two separate paths. This division can occur either deliberately or inadvertently. Typically, a hard fork arises from significant protocol upgrades, whereas an unintentional fork may result from software bugs.
Additionally, forks can be temporary, where the chain diverges until it identifies the longest and heaviest chain, ultimately leading to consistency. This temporary fork happens when two blocks are generated nearly simultaneously, causing the chain to split until it resolves to the dominant chain.
Ethash of Ethereum
Ethash refers to the proof-of-work (PoW) algorithm utilized by Ethereum. Initially introduced as the Dagger-Hashimoto algorithm, it has undergone significant changes since its original implementation, evolving into what is now recognized as Ethash.
Much like Bitcoin, the fundamental concept of mining involves discovering a nonce, which is a random number. When this nonce is combined with the block header and hashed, it produces a value that must be lower than the current network difficulty.
In the early days of Ethereum, the difficulty level was relatively low, allowing for profitable mining using CPUs and single GPUs.
Ethash DAG of Ethereum
Ethash is a memory-intensive algorithm, which poses challenges for implementation on specialized hardware. Similar to Bitcoin, where ASICs have been created leading to mining centralization, memory-hard proof-of-work algorithms serve as a countermeasure to this issue.
Ethereum employs Ethash to deter the development of ASICs for mining purposes. The nature of Ethash makes it impractical to create ASICs with extensive and rapid memory capabilities. This algorithm necessitates the selection of subsets from a fixed resource known as the Directed Acyclic Graph (DAG), which is determined by the nonce and block headers.
The DAG is a substantial dataset generated in a pseudo-random manner. It is represented as a matrix within the DAG file produced during the Ethereum mining process. The Ethash algorithm requires the DAG to be formatted as a two-dimensional array of 32-bit unsigned integers. Mining can only commence once the DAG has been fully generated during the initial startup of a mining node. This DAG serves as a seed for the Ethash algorithm. According to the current specifications, the epoch duration is set at 30,000 blocks, approximately equivalent to six days.
How Ethash Works?
The Ethash algorithm operates with the necessity of a DAG file. This file is created every epoch, which consists of 30,000 blocks. As the blockchain expands, the size of the DAG increases linearly.
Currently, the DAG size is approximately 3.5 GB (as of block 9325164) and is at epoch number 310.
The protocol functions in the following manner −
* Initially, the header from the preceding block is combined with a 32-bit random nonce using the Keccak-256 hashing function.
* This combination results in a 128-bit structure known as the mix.
* The mix is responsible for determining which data will be retrieved from the DAG.
* After the data is obtained from the DAG, it is "mixed" with the current mix to generate a new mix, which is then used to fetch additional data from the DAG.
* Ultimately, the 64th mix undergoes a digest function to yield a 32-byte sequence.
* This sequence is then compared against the difficulty target. If it falls below the target, the nonce is deemed valid, and the proof of work is successfully completed, resulting in the mining of the block.
* If it does not meet the target, the algorithm will initiate the process again with a different nonce.
Consider a situation shown in image −
As clearly seen here, Bob is tendering a $10 bill to Lisa in exchange of a book. Once the Lisa receives this physical $10 bill, there is no way for Bob to re-use this money for some other transaction, as the physical currency is now in Lisa’s possession.
Now, consider a situation where the money is paid in Digital form. This is illustrated in image −
As the format for money exchange is in the digital format, it is essentially a binary physical file stored somewhere on Bob’s device. After Bob gives this file (digital money) to Lisa, he can also a give a copy of the file to Alice. Both now think that they have received the money without having any means of authenticating the digital coin and would thus deliver their respective goods to Bob. This is called double-spending where the sender spends the same money at more than one place for obtaining services or goods from multiple vendors.
To solve this problem of double-spending, one would employ a centralized authority to monitor all the transactions. This is illustrated in image −
The centralized authority, which in common terms is your bank, maintains a ledger book recording all the transactions. Now, Bob has to send his digital money to the bank who would make an entry into its ledger debiting Bob’s account. After ensuring that Bob has sufficient balance to pay for the digital money which he wants to send, would send the money to Lisa crediting her account in its ledger.
Now, it is guaranteed that Bob cannot double spend the money. If every digital transaction is routed through a centralized authority like this, the problem of double-spending would be solved. This also provides another benefit in validating the authenticity of each coin (digital money) that it receives in the transaction. So the fake money (duplicate money as in the case of Bob paying to Alice using a copy) would be easily detected and prevented from the circulation.
The introduction of centralized authority though it solves the double-spending problem, introduces another major issue - the cost of creating and maintaining the centralized authority itself.
As the banks need money for their operations, they start cutting commissions on each currency transaction they do for their clients. This sometimes can become very expensive, especially in overseas transfer of money where multiple agents (banks) may be involved in the entire deal.
All the above issues are solved by the introduction of digital currency, called Bitcoin. I will now give you a brief background on what Bitcoin is before delving into its design and architecture.
Public Key Cryptography or in short PKI is also known as asymmetric cryptography. It uses two pairs of keys - public and private. A key is a some long binary number. The public key is distributed worldwide and is truly public as its name suggests. The private key is to be strictly held private and one should never lose it.
In case of Bitcoin, if you ever lose the private key to your Bitcoin wallet, the entire contents of your wallets would be instantly vulnerable to theft and before you know it, all your money (the contents of your wallet) would be gone with no mechanism in the system to trace out who stole it - that is the anonymity in the system that I mentioned earlier.
The PKI accomplies two functions - authentication and the message privacy through encryption/decryption mechanism. I will now explain both these functions −
Authentication
When the two parties exchange messages, it is important to establish a trust between the sender and the receiver. Especially, the receiver must trust the source of message. Going to our earlier scenario (depicted in Figure 1) of Bob sending some money to Lisa for purchasing of some goods from her, let us see how the PKI builds this trust between Bob and Lisa. Look at below image −
In the first place, if Bob wants to send some money to Lisa, he has to create a private/public key of its own. Note that both keys are always paired together and you can not mix the private and public keys of different individuals or different instances.
Now, Bob says that he is sending $10 to Lisa. So he creates a message (a plain-text message) containing Bob’s (sender) public key, Lisa’s (receiver) public key, and the amount ($10).
The purpose of this remittance such as “I want to buy pumpkin from you” is also added into the message. The entire message is now signed using Bob’s private key. When Lisa receives this message, she will use the signature verification algorithm of PKI and Bob’s public key to ensure that the message indeed originated from Bob. How the PKI works is beyond the scope of this tutorial. The interested reader is referred to this site for a more detailed discussion on PKI. This establishes the authenticity of the message originator. Now, let us look at the message privacy.
Message Privacy
Now, as Lisa has received her payment, she wants to send the link to her ebook which Bob wants to buy. So Lisa would create a message and send it to Bob as shown in image −
The Lisa creates a message such as “Here is the link to my ebook which you had requested”, signs it with Bob’s public key that she has received in Bob’s request message and also encrypts the message using some secret key which is shared between the two during HTTPS handshake.
Now, Lisa is sure that only Bob can decode the message using the private key that is held by Bob alone. Also, somebody intercepting the message would not be able to recover its contents because the contents are encrypted by a secret key held only by Bob and Alice. This guarantees to Lisa that access to her ebook is granted only to Bob.
Having seen both the features, Authentication and Message Privacy, implied by PKI, let us move ahead to see how Bitcoin makes use of PKI to secure the public ledger that I mentioned in the chapter “What is Bitcoin?”.
For your knowledge − The most popular PKI algorithms are RSA and ECDSA, Bitcoin uses the latter one.
One of the most important function in PKI is the hashing function. A hash function maps the data of any arbitrary size to data of fixed size. Bitcoin uses SHA-256 hash function that produces a hash (output) of size 256 bits (32 bytes). This is illustrated in image −
Bob, while placing an order with Lisa, creates a message similar to the one shown above. This message is hashed through a hash function that produces a 32 byte hash. The beauty of this hash is for all practical purposes the hash (the 256-bit number) is considered unique for the contents of the message. If the message is modified, the hash value will change. Not only that given a hash value, it is impossible to reconstruct the original message.
After having seen the importance of hashing, let us move on another concept in Bitcoin that is mining.
When Bob creates a purchase request for Lisa, he does not send it to Lisa alone. Rather the request message is broadcasted on the entire network to which he is connected. Bob’s network is depicted in image.
The message goes to all the connected nodes (machines). Some of the nodes in the diagram are marked as miners. These are the machines which run a piece of software for mining the bitcoin message. I will now explain you what this mining means.
Mining Process
As the entire network is widely distributed, every miner in the network is expected to receive multiple messages from multiple vendors at any given period of time. What the miner does is he combines these messages in a single block. This is illustrated in image −
After a block of messages is formed, the miner creates a hash on the block using the hashing function described earlier. Now, as you know if any third party modifies the contents of this block, its hash would become invalid. Incidentally, each message is time-stamped so that nobody can modify its chronological order without affecting the block’s hash value. Thus, the messages in the block are perfectly secured from tampering. How this fact is used in securing all the transactions in the network is explained further.
The blocks created by various miners are chained together to form what is known as a truly distributed public ledger.
Each block in the chain contains multiple messages (transactions) as seen earlier in Figure 8. A block in the chain may come from any miner. While creating the chain of blocks, we observe the rule that hash of the previous block is added to the current block.
Thus, a miner while creating the block, picks up the hash of the last block in the chain, combines it with its own set of messages and creates a hash for its newly created block. This newly created block now becomes the new end for the chain and thus the chain keeps on growing as more and more blocks are added to it by the miners.
As all transactions are time stamped, we need to implement a distributed timestamp server on a peer-to-peer network. This requires some additional implementation and that is the Proof-of-Work that I will describe now. To each block, we now add one more item called Nonce as shown in the figure below −
Nonce is a number such that the block’s hash meets a certain criterion. This criterion could be that the generated hash must have its leading four digits to be zero.
Thus, the generated hash would look like 000010101010xxx. Generally, the miner starts with a Nonce value of 0 and keeps on incrementing it until the generated hash meets the specified criterion.
Note that the hash generation works at random and is beyond your control - that is you cannot force the hash function to generate a certain hash. Thus, it may take several iterations until the desired hash with four leading zeros is generated. The expected time for generating a block in bitcoin system is 10 minutes. Once the miner successfully mines the block, he releases that in the system making it now the last block in the chain.
Note that there are multiple miners competing to generate the legitimate block. The Bitcoin system awards the first successful miner by giving him certain bitcoins. In general, the miner with more computing power may be an early winner. This can cause attacks on the entire system by those who possess a huge processing power. I will describe the attacks and how these are mitigated towards the end of this tutorial.
I will now summarize the steps described above; this is what happens in the network −
* Anybody who wants to obtain services from the third party who has advertised on the network first creates a transaction (message to the desired recipient).
* Over a given period of time, there could be many senders (buyers) and receivers (sellers) creating such transactions.
* All transactions are broadcast on the network to all nodes. Note that it is not necessary that a given transaction must reach each and every other node in the network.
* Each node assembles the new transactions into a block. Note that the set of transactions in each block is independent of the set in blocks created by others and will naturally be different than others. This does not matter; the system ensures that every transaction broadcast on the network gets included in some block over a reasonable amount of time. Generally, the sender will incentivize the node by offering a certain amount of bitcoins to the miner for its efforts. The miner may opt for giving priority for inclusion in the block to those with higher incentives.
* The node now works on finding the proof-of-work for its assembled block.
* When the node finds a proof-of-work, it broadcasts the assembled block on the network.
* The nodes that receive the new block will accept it only after verifying that all transactions in the block are valid and not already spent.
* If the block is accepted as valid, the node which is working on its own new block will have to re-assemble the transactions in its block ensuring that the transactions are not duplicated. The node now works on finding the proof-of-work on its newly created block; while doing so it will take the hash of the accepted block as the previous hash.
* Likewise, the blockchain continues growing for ever.
Now, as we have seen how the entire system works, let me describe some of the side effects and how to resolve them.
As we saw in the chapter Bitcoin - Mining, a miner may be flooded with many transactions at any given period of time. The maximum size for a block is pre-defined in the system necessitating that only a certain number of transactions be included in the block.
The number of transactions in the block is determined by the pre-defined block size and the average length of each block. An important tip here is that the sender should not include too much information in its message so as to make it short and thereby incentivizing the miner to accept it before the other lengthy messages.
A sender generally will also add a transaction fee in terms of a certain number of bitcoins so as to incentivize the miner for early inclusion in his block.
The other consequence in building the blockchain is its mere size. Over a period of time, the entire blockchain may become too large for a node to store it on its disk. This is solved by using Merkle Tree which is described next.
The issue of disk space in a node is easily overcome because all transactions in a block are hashed in a Merkle Tree as shown in image −
The block header now contains the hash of the previous block, a Nonce, and the Root Hash of all the transactions in the current block in a Merkle Tree. As this Root Hash includes the hashes of all the transactions within the block, these transactions may be pruned to save the disk space. So now your blockchain will look like in below image −
This can result in a lots of saving in the disk space. This strategy is used by a normal client who is interested in just receiving payments from others. However, the miners need to save the full blockchain. Now the question arises, how a receiver verifies the payment without having the ability to trace a received coin right to its origin. This is explained next.
Consider a case whereby as a vendor you may like to verify a certain payment made in the past. As the blockchain you are holding on your machine contains only the block headers as shown in the earlier figure, the transaction that you are searching for is missing in the copy of your blockchain.
You can now search backwards in your copy of the blockchain until you find a block in which the desired transaction is timestamped in. Now, request the merkle tree of the selected block and you will have the transaction that you are looking for. This is illustrated in below Figure −
Here, we assume that you are looking for Tx103. Though you may not be able to see the contents of Tx103, you know that this has been accepted by the block to which it belongs and all subsequent blocks in the chain. Thus, you can safely trust this transaction and proceed with your business.
As we have seen the Bitcoin network contains several miners. It is possible, that the two different miners solve the Proof-of-Work at the same time and thus add their blocks to the last known block in the chain. This is illustrated in below image −
Now, we have two branches after Block 3. Both the branches are valid. So the next mined block may be added in either of the branches. Suppose, the miner adds the newly mined block to Block 104-A, the branch containing Block 104-A will be longer than the branch containing Block 104-B. This is illustrated in below image −
In Bitcoin architecture, the longest branch always wins and the shorter ones are purged. So the Block 104-B has to be purged. Before purging this block, all transactions in this block will be returned to the transaction pool so that they are mined and added to some future block. This is how the conflicts are resolved and only one single chain of blocks is maintained by the system.
As the ledger which is recording all the bitcoin transactions is made truly public, the privacy is at stake. Anybody in the world would be able to know who paid whom? The traditional banking system is able to maintain this kind of privacy by keeping its records confidential.
Privacy in Bitcoin system is achieved by a different strategy. Note that we said that the sender of a bitcoin needs to know whom to pay. So he asks for the public key of the vendor to which he desires to make the payment. This public key can be anonymous.
In the sense, as a vendor of some services, when somebody asks you where to send the payment, you would simply send him your public key. The association of this public key with you is not recorded anywhere in the ledger. That way anybody outside of this transaction would only know how much money is transacted and to which public key the money is paid out.
To achieve a higher degree of privacy, for every transaction, you may generate a new private/public key for each transaction so that multiple transactions made by you cannot be grouped together by a third party. For an outsider, this would simply mean that multiple transactions of smaller values were made and they will never will be linked to a common source.
Lastly, any online internet based system is vulnerable to abuses. I will now describe few possible types of attacks on Bitcoin system and how those are mitigated.
I will discuss three different types of probable attacks in the Bitcoin system −
Race Attack
As an attacker, you may send the same coin to different vendors in rapid succession, probably by using two different machines. If the vendors do not wait for the block confirmation before delivering the goods, they will very soon realize that the transaction was rejected during the mining process. The solution to this kind of attack is that the vendor must wait for at least one block confirmation before sending out the goods.
Finney Attack
In this case, the attacker is the miner. The miner mines a block with his transaction and does not release it in the system. He now uses the same coins in a second transaction and then releases the pre-mined block. Obviously, the second transaction would be rejected eventually by other miners, but this will take some time. To mitigate this risk, the seller should wait for at least six block confirmations before releasing the goods.
The 51% Attack
In this kind of attack, we come up with an impractical assumption that somebody owns 51% of the computing power of the network. The attacker in this kind of attack mines a private blockchain where he double-spends the coins.
As he owns the majority of computing power, he is guaranteed that his private blockchain at some point of time would be longer than the chain of “honest” network. He then releases his private blockchain in the system making all the transactions earlier recorded in the honest blockchain to be invalid.
This kind of attack is fictitious as it is very expensive to acquire computing power which equals or exceeds 51% of the computing power of the entire network.
In this short tutorial you were introduced to several concepts of Blockchain by taking Bitcoin as a case study. The Bitcoin is the first successful implementation of blockchain. Today, the world has found applications of blockchain technology in several industries, where the trust without the involvement of a centralized authority is desired. So welcome to the world of Blockchain.
Further Readings −
* Original paper by Satoshi − Bitcoin: A Peer-to-Peer Electronic Cash System
* Official site − Bitcoin.org